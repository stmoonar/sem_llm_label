{
    "authorId": "2431881",
    "papers": [
        {
            "paperId": "8a585c13f2fe0c924b15b1d2b0d0d3ef04ee40ec",
            "title": "Human-assisted OCR of Japanese books with different kinds of microtasks",
            "abstract": "Human-assisted OCR is a common approach for transcribing books and has been used for many digital library projects. This paper reports our project for transcribing the book collections of National Diet Library in this approach. Our project is unique in two ways. First, we try to extend the human-assisted OCR approach by distributing microtasks in many ways other than just showing tasks in the speci\ufb01c Web page on PC screens. Second, we deal with Japanese books which have thousands of characters, some of which look similar to each other. This paper shows that we can expect high-quality results even if we transcribe Japanese texts with microtasks and the number of preformed microtasks to be stable if we distribute microtasks to equipment with witch worker perform microtasks in their daily lives",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                },
                {
                    "authorId": "2066202084",
                    "name": "Ryota Hayashi"
                },
                {
                    "authorId": "32828225",
                    "name": "K. Nagasaki"
                },
                {
                    "authorId": "34573158",
                    "name": "Atsuyuki Morishima"
                }
            ]
        },
        {
            "paperId": "2ff37b75058ee39cf9fcffedce9a3d777af6a8c5",
            "title": "Bookshelf problem: a human-in-the-loop approach for data grouping without complete information",
            "abstract": "The problem of dividing a given set of data items into groups in the situation that the given input is not su cient to solve it has a wide range of applications. However, the problem cannot be solved by computers alone. This paper defines the Bookshelf problem to deal with such a problem and discusses how to solve the problem with the help of humans. Intuitively, the Bookshelf problem is as follows. Given a set of books with tags and a book cabinet with N shelves, we need to construct N groups of books s.t. all books in each group share at least one common tag. However, the given tags and their connections to books may not be su cient to make groups, and we have to find the missing tags and connections. This paper proposes a systematic human-in-the-loop method that uses two types of microtasks to solve the problem, and experimentally shows that human intelligence is e ective to avoid the worst-case search.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "31710208",
                    "name": "Emi Sakurai"
                },
                {
                    "authorId": "34573158",
                    "name": "Atsuyuki Morishima"
                },
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                },
                {
                    "authorId": "50777492",
                    "name": "Nobutaka Suzuki"
                }
            ]
        },
        {
            "paperId": "3b5a67a7dbe0fffd270d7178c62fe061ac209c63",
            "title": "A Study on Algorithms for Finding Correct XPath Queries",
            "abstract": "If a query written by a user does not return a desirable answer, then the user have to correct the query. In such cases, a method for helping users to write correct queries is much useful. For relational databases (RDBs), methods for helping users to write correct SQL queries have been proposed. On the other hand, Extensible Markup Language (XML) essentially has a much more complex data structure than RDB. Thus, helping users to write correct queries is a much more difficult problem, and very few effective methods for dealing with the problem have been proposed so far. In order to help users to write correct queries, information about correct data structures is required. There are two possible approaches to obtain such information: (1) gathering structural information from data and (2) referring schema information instead of data. However, the former approach has some drawbacks. First, it is sometimes impossible to access some or entire part of data due to privacy and/or security reasons. Second, the size of data is extremely larger than that of schema, and large data is hard to be processed in environments with small resources. In such situations, it is useful to help users to write correct queries by using schema rather than data. Therefore, this dissertation focuses on the latter approach and considers correcting queries by using the structural information of schema. Assuming this approach, there are two possibilities to help users to write",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                }
            ]
        },
        {
            "paperId": "7ecb34ecf8a6d3171ca4cd0c558b2071b3a74297",
            "title": "Collaborative Crowdsourcing with Crowd4U",
            "abstract": "Collaborative crowdsourcing is an emerging paradigm where a set of workers, often with diverse and complementary skills, form groups and work together to complete complex tasks. While crowdsourcing has been used successfully in many applications, collaboration is essential for achieving a high quality outcome for a number of emerging applications such as text translation, citizen journalism and surveillance tasks. However, no crowdsourcing platform today enables the end-to-end deployment of collaborative tasks. We demonstrate Crowd4U, a volunteer-based system that enables the deployment of diverse crowdsourcing tasks with complex data-flows, in a declarative manner. In addition to treating workers and tasks as rich entities, Crowd4U also provides an easy-to-use form-based task UI. Crowd4U implements worker-to-task assignment algorithms that are appropriate for each kind of task. Once workers are assigned to tasks, appropriate worker collaboration schemes are enforced in order to enable effective result coordination.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                },
                {
                    "authorId": "34573158",
                    "name": "Atsuyuki Morishima"
                },
                {
                    "authorId": "123014225",
                    "name": "Habibur Rahman"
                },
                {
                    "authorId": "1702973",
                    "name": "Senjuti Basu Roy"
                },
                {
                    "authorId": "2934941",
                    "name": "Saravanan Thirumuruganathan"
                },
                {
                    "authorId": "1403657578",
                    "name": "S. Amer-Yahia"
                },
                {
                    "authorId": "145080425",
                    "name": "Gautam Das"
                }
            ]
        },
        {
            "paperId": "d1d8ed460ed7f9d58098c82840a93563b8f0d73a",
            "title": "An Algorithm for All-Pairs Regular Path Problem on External Memory Graphs",
            "abstract": "SUMMARY In this paper, we consider solving the all-pairs regular path problem on large graphs e \ufb03 ciently. Let G be a graph and r be a regular path query, and consider \ufb01nding the answers of r on G . If G is so small that it \ufb01ts in main memory, it su \ufb03 ces to load entire G into main memory and traverse G to \ufb01nd paths matching r . However, if G is too large and cannot \ufb01t in main memory, we need another approach. In this paper, we propose a novel approach based on external memory algorithm. Our algorithm \ufb01nds the answers matching r by scanning the node list of G sequentially. We made a small experiment, which suggests that our algorithm can solve the problem e \ufb03 ciently.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "50777492",
                    "name": "Nobutaka Suzuki"
                },
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                },
                {
                    "authorId": "2086548",
                    "name": "Yeondae Kwon"
                }
            ]
        },
        {
            "paperId": "abcdf066ca89018d12906b81bfe01579945cedf7",
            "title": "An Algorithm for Finding top-K Valid XPath Queries",
            "abstract": "Suppose that we have a DTD and XML documents valid against the DTD, and consider writing an XPath query to the documents. Unfortunately, a user often does not understand the entire structure of the documents exactly, especially in the case where the documents are very large and/or complex, or the DTD has been updated but the user misses it. In such cases, the user tends to write an invalid XPath query. However, it is difficult for the user to correct the query by hand due to his/her lack of exact knowledge about the entire structure of the documents. In this paper, we propose an algorithm that finds, for an XPath query q, a DTD D, and a positive integer K, top-K XPath queries most syntactically close to q among the XPath queries conforming to D, so that a user select an appropriate query among the K queries. We also present some experimental studies.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                },
                {
                    "authorId": "50777492",
                    "name": "Nobutaka Suzuki"
                }
            ]
        },
        {
            "paperId": "097cdd9865f1498f3e58b4058557db0b9f668687",
            "title": "Satisfiability of Simple XPath Fragments under Duplicate-Free DTDs",
            "abstract": "SUMMARY In this paper, we consider the XPath satisfiability problem under restricted DTDs called \u201cduplicate free\u201d. For an XPath expression q and a DTD D, q is satisfiable under D if there exists an XML document t such that t is valid against D and that the answer of q on t is nonempty. Evaluating an unsatisfiable XPath expression is meaningless, since such an expression can always be replaced by an empty set without evaluating it. However, it is shown that the XPath satisfiability problem is intractable for a large number of XPath fragments. In this paper, we consider simple XPath fragments under two restrictions: (i) only a label can be specified as a node test and (ii) operators such as qualifier ([]) and path union (\u222a )a re not allowed. We first show that, for some small XPath fragments under the above restrictions, the satisfiability problem is NP-complete under DTDs without any restriction. Then we show that there exist XPath fragments, containing the above small fragments, for which the satisfiability problem",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "50777492",
                    "name": "Nobutaka Suzuki"
                },
                {
                    "authorId": "2056187674",
                    "name": "Yuji Fukushima"
                },
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                }
            ]
        },
        {
            "paperId": "d039c58b38b8585b4921d9fedbb9b2ed0c53510b",
            "title": "An Algorithm for Transforming XPath Expressions According to Schema Evolution",
            "abstract": "XML is a de-fact standard format on the Web. In general, schemas of XML documents are continuously updated according to changes in real world. If a schema is updated, then query expressions have to be transformed so that they are \\valid\" under the updated schema, since the expressions are no longer valid under the updated schema due to the schema update. However, this is not an easy task since many of recent schemas are large and complex and thus it is becoming difficult to know how to update the query expressions correctly. In this paper, we propose an algorithm for transforming XPath expressions according to schema evolution. For an XPath expression p and a schema S , our algorithm treats both p and S as tree automata T A p and T A S,",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2067836200",
                    "name": "Kazuma Hasegawa"
                },
                {
                    "authorId": "2431881",
                    "name": "Kosetsu Ikeda"
                },
                {
                    "authorId": "50777492",
                    "name": "Nobutaka Suzuki"
                }
            ]
        }
    ]
}