{
    "authorId": "1850588",
    "papers": [
        {
            "paperId": "f8b975d39d7434c6582413757341adb45385a3ff",
            "title": "Secure Protocols for Best Arm Identification in Federated Stochastic Multi-Armed Bandits",
            "abstract": "The stochastic multi-armed bandit is a classical reinforcement learning model, where a learning agent sequentially chooses an action (pull a bandit arm) and the environment responds with a stochastic reward drawn from an unknown distribution associated with the chosen action. A popular objective for the agent is to identify the arm having the maximum expected reward, also known as the best arm identification problem. We address the security concerns that occur in a cross-silo federated learning setting, where multiple data owners collaborate under the orchestration of a server to execute a best arm identification algorithm. We propose three secure protocols, which guarantee desirable security properties for the: input data (i.e., reward values), intermediate data (i.e., sums of rewards), and output data (i.e., ranking of arms and in particular the identified best arm). More precisely: (1) no data owner can learn the identified best arm; moreover, no data owner can learn local data pertaining to another data owner; (2) the orchestration participants cannot learn the identified best arm, any reward value, or any sum of rewards; (3) by analyzing the messages exchanged over the network, an external observer cannot learn the identified best arm, or any reward value, or any sum of rewards. Each protocol has a different architecture, uses different techniques, and proposes a different trade-off with respect to several criteria that we thoroughly analyze: number of participants, generality of the supported reward functions, cryptographic overhead, and communication cost. To build our protocols, we rely on secure multi-party computation, AES-CBC, and the additive homomorphic property of Paillier.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "2003478279",
                    "name": "Anatole Delabrouille"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                }
            ]
        },
        {
            "paperId": "0f0dbf15b04d43b8ca657db62f3ec8a1fe441fb3",
            "title": "Implementing Linear Bandits in Off-the-Shelf SQLite",
            "abstract": "The linear multi-armed bandit is a reinforcement learning model that is largely used for sequential decision making in applications such as online advertising and recommender systems. We show that LinUCB, a well-known cumulative reward maximization algorithm for linear bandits, can be implemented in off-the-shelf SQLite. Additionally, our empirical study shows that, when dealing with small bandit data, our SQLite implementation is faster than an implementation in off-the-shelf Python. We believe that our findings open the door for many promising research directions on the topic of in-DBMS federated learning because (i) in the federated learning paradigm, many data owners contribute to the same learning task while locally storing their small data, and (ii) SQLite is a DBMS embedded in billions of devices, hence being able to implement federated learning on top of SQLite is of great practical interest.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                },
                {
                    "authorId": "1403657578",
                    "name": "S. Amer-Yahia"
                }
            ]
        },
        {
            "paperId": "4376afd3aaab169e10c263f7de2ebb3dea0969b7",
            "title": "FeReD: Federated Reinforcement Learning in the DBMS",
            "abstract": "Federated learning enables clients to enrich their locally trained models via updates performed by a coordination server based on aggregates of local models. There are multiple advances in methods and applications of federated learning, in particular in cross-device federation, where clients having limited data and computational resources collaborate in a joint learning problem. Given the constraint of limited resources in cross-device federation, we study the potential benefits of embedded in-DBMS learning, illustrated in a federated reinforcement learning problem. We demonstrate FeReD, a system that contrasts the performance of cross-device federation using Q-learning, a popular reinforcement learning algorithm. FeReD offers step-by-step guidance for in-DBMS SQLite implementation challenges for both horizontal and vertical data partitioning. FeReD also allows to contrast the Q-learning implementations in SQLite vs a standard Python implementation, by highlighting their learning performance, computational efficiency, succinctness and expressiveness. A video of FeReD is available at https://www.youtube.com/watch?v=2kRIu_C5RZA and its open source code at https://github.com/sotostzam/FeReD.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2114808871",
                    "name": "Sotirios Tzamaras"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                },
                {
                    "authorId": "1403657578",
                    "name": "S. Amer-Yahia"
                }
            ]
        },
        {
            "paperId": "6be58b3dd64a454e0d7cae9a7cdb119261e1e993",
            "title": "Samba: A System for Secure Federated Multi-Armed Bandits",
            "abstract": "The federated learning paradigm allows several data owners to contribute to a machine learning task without exposing their potentially sensitive data. We focus on cumulative reward maximization in Multi-Armed Bandits (MAB), a classical reinforcement learning model for decision making under uncertainty. We demonstrate Samba, a generic framework for Secure federAted Multi-armed BAndits. The demonstration platform is a Web interface that simulates the distributed components of Samba, and which helps the data scientist to configure the end-to-end workflow of deploying a federated MAB algorithm. The user-friendly interface of Samba, allows the users to examine the interaction between three key dimensions of federated MAB: cumulative reward, computation time, and security guarantees. We demonstrate Samba with two real-world datasets: Google Local Reviews and Steam Video Game.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2156288551",
                    "name": "Gael Marcadet"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                },
                {
                    "authorId": "1403657578",
                    "name": "S. Amer-Yahia"
                }
            ]
        },
        {
            "paperId": "c1d4d650321968f754c878787a9f9759829d1f4b",
            "title": "Secure protocols for cumulative reward maximization in stochastic multi-armed bandits",
            "abstract": "We consider the problem of cumulative reward maximization in multi-armed bandits. We address the security concerns that occur when data and computations are outsourced to an honest-but-curious cloud i.e., that executes tasks dutifully, but tries to gain as much information as possible. We consider situations where data used in bandit algorithms is sensitive and has to be protected e.g., commercial or personal data. We rely on cryptographic schemes and propose UCB - MS, a secure multi-party protocol based on the UCB algorithm. We prove that UCB - MS computes the same cumulative reward as UCB while satisfying desirable security properties. In particular, cloud nodes cannot learn the cumulative reward or the sum of rewards for more than one arm. Moreover, by analyzing messages exchanged among cloud nodes, an external observer cannot learn the cumulative reward or the sum of rewards produced by some arm. We show that the overhead due to cryptographic primitives is linear in the size of the input. Our implementation confirms the linear-time behavior and the practical feasibility of our protocol, on both synthetic and real-world data.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "1412406528",
                    "name": "Marius Lombard-Platet"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                }
            ]
        },
        {
            "paperId": "c559c1ceffe7ba9a17851620cd310b8b9e563a3c",
            "title": "SAMBA: A Generic Framework for Secure Federated Multi-Armed Bandits",
            "abstract": "The multi-armed bandit is a reinforcement learning model where a learning agent repeatedly chooses an action (pull a bandit arm) and the environment responds with a stochastic outcome (reward) coming from an unknown distribution associated with the chosen arm. Bandits have a wide-range of application such as Web recommendation systems. We address the cumulative reward maximization problem in a secure federated learning setting, where multiple data owners keep their data stored locally and collaborate under the coordination of a central orchestration server. We rely on cryptographic schemes and propose Samba, a generic framework for Secure federAted Multi-armed BAndits. Each data owner has data associated to a bandit arm and the bandit algorithm has to sequentially select which data owner is solicited at each time step. We instantiate Samba for five bandit algorithms. We show that Samba returns the same cumulative reward as the nonsecure versions of bandit algorithms, while satisfying formally proven security properties. We also show that the overhead due to cryptographic primitives is linear in the size of the input, which is confirmed by our proof-of-concept implementation.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "2156288551",
                    "name": "Gael Marcadet"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                }
            ]
        },
        {
            "paperId": "5480019f7a5f9cabad878f76e06dced41b5b7ad7",
            "title": "DashBot: An ML-Guided Dashboard Generation System",
            "abstract": "Data summarization provides a bird's eye view of data and groupby queries have been the method of choice for data summarization. Such queries provide the ability to group by some attributes and aggregate by others, and their results can be coupled with a visualization to convey insights. The number of possible groupbys that can be computed over a dataset is quite large which naturally calls for developing approaches to aid users in choosing which groupbys best summarize data. We demonstrate DashBot, a system that leverages Machine Learning to guide users in generating data-driven and customized dashboards. A dashboard contains a set of panels, each of which is a groupby query. DashBot iteratively recommends the most relevant panel while ensuring coverage. Relevance is computed based on intrinsic measures of the dataset and coverage aims to provide comprehensive summaries. DashBot relies on a Multi-Armed Bandits (MABs) approach to balance exploitation of relevance and exploration of different regions of the data to achieve coverage. Users can provide feedback and explanations to customize recommended panels. We demonstrate the utility and features of DashBot on different datasets.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "102397366",
                    "name": "S. D. Col"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                },
                {
                    "authorId": "2135814451",
                    "name": "Nassim Bouarour"
                },
                {
                    "authorId": "1403657578",
                    "name": "S. Amer-Yahia"
                }
            ]
        },
        {
            "paperId": "0cc466ab156c2ed3da95da84040d472e1403d3c4",
            "title": "Secure Outsourcing of Multi-Armed Bandits",
            "abstract": "We consider the problem of cumulative reward maximization in multi-armed bandits. We address the security concerns that occur when data and computations are outsourced to an honest-but-curious cloud i.e., that executes tasks dutifully, but tries to gain as much information as possible. We consider situations where data used in bandit algorithms is sensitive and has to be protected e.g., commercial or personal data. We rely on cryptographic schemes and propose UCB-DS, a distributed and secure protocol based on the UCB algorithm. We prove that UCB-DS computes the same cumulative reward as UCB while satisfying desirable security properties. In particular, cloud nodes cannot learn the cumulative reward or the sum of rewards for more than one arm. Moreover, by analyzing messages exchanged among cloud nodes, an external observer cannot learn the cumulative reward or the sum of rewards produced by some arm. We show that the overhead due to cryptographic primitives is linear in the size of the input. Our implementation confirms the linear-time behavior and the practical feasibility of our protocol, on both synthetic and real-world data.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "1412406528",
                    "name": "Marius Lombard-Platet"
                },
                {
                    "authorId": "144004707",
                    "name": "Marta Soare"
                }
            ]
        },
        {
            "paperId": "ec995ce79f0936b14578573486794ddd5723ca99",
            "title": "Demonstration of GOOSE: A Secure Framework for Graph Outsourcing and SPARQL Evaluation",
            "abstract": "We demonstrate GOOSE, an open-source framework for secure graph outsourcing and SPARQL evaluation. We showcase the workflow of GOOSE over various real-world use cases, the scalability of GOOSE, and the security properties that GOOSE guarantees in the honest-but-curious cloud security model.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                }
            ]
        },
        {
            "paperId": "1375fbefadc128d7c533905f57105e040488b663",
            "title": "Secure Intersection with MapReduce",
            "abstract": "Relation intersection is a fundamental problem, which becomes non-trivial when the relations to be intersected are too large to fit on a single machine. Hence, a natural approach is to design parallel algorithms that are executed on a cluster of machines rented from a public cloud provider. Intersection of relations becomes even more difficult when each relation belongs to a different data owner that wants to protect her data privacy. We consider the popular MapReduce paradigm for outsourcing data and computations to a semi-honest public cloud. Our main contribution is the SI protocol (for Secure Intersection) that allows to securely compute the intersection of an arbitrary number of relations, each of them being encrypted by its owner. The user allowed to query the intersection result has only to decrypt the result sent by the public cloud. SI does not leak (to the public cloud or to the user) any information on tuples that are not in the final relation intersection result, even if t he public cloud and the user collude i.e., they share all their private information. We prove the security of SI and provide an empirical evaluation showing its efficiency.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "153528762",
                    "name": "Matthieu Giraud"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "46269913",
                    "name": "Lihua Ye"
                }
            ]
        },
        {
            "paperId": "28018686d081897aebb21ab2918869d89cec2e4b",
            "title": "Secure Strassen-Winograd Matrix Multiplication with MapReduce",
            "abstract": "Matrix multiplication is a mathematical brick for solving many real life problems. We consider the Strassen-Winograd algorithm (SW), one of the most efficient matrix multiplication algorithms. Our first contribution is to redesign SW with the MapReduce programming model that allows to process big data sets in parallel on a cluster. Moreover, our main contribution is to address the inherent security and privacy concerns that occur when outsourcing data to a public cloud. We propose a secure approach of SW with MapReduce called S2M3, for Secure Strassen-Winograd Matrix Multiplication with MapReduce. We prove the security of our protocol in a standard security model and provide a proof-of-concept empirical evaluation suggesting its efficiency.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "153528762",
                    "name": "Matthieu Giraud"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "46269913",
                    "name": "Lihua Ye"
                }
            ]
        },
        {
            "paperId": "5ef669af26dc1203c828078a72b6fdcc03a52750",
            "title": "Secure Grouping and Aggregation with MapReduce",
            "abstract": "MapReduce programming paradigm allows to process big data sets in parallel on a large cluster. We focus on a scenario where the data owner outsources her data on an honest-but-curious server. Our aim is to evaluate grouping and aggregation with SUM, COUNT, AVG, MIN, and MAX operations for an authorized user. For each of these five operations, we assume that the public cloud provider and the user do not collude i.e., the public cloud does not know the secret key of the user. We prove the security of our approach for each operation.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "153528762",
                    "name": "Matthieu Giraud"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                },
                {
                    "authorId": "46269913",
                    "name": "Lihua Ye"
                }
            ]
        },
        {
            "paperId": "10b459796ff7af5e0171bb3c4bcbee72ce0ae884",
            "title": "Synthetic Graph Generation from Finely-Tuned Temporal Constraints",
            "abstract": "Large-scale graphs are at the core of a plethora of modern applications such as social networks, transportation networks, or the Semantic Web. Such graphs are naturally evolving over time, which makes particularly challenging graph processing tasks e.g., graph mining. To be able to realize rigorous empirical evaluations of research ideas, the graph processing community needs finely-tuned generators of synthetic time-evolving graphs, which are particularly useful whenever real-world graphs are unavailable for public use. The goal of this paper is to report on an ongoing project that aims at generating synthetic time-evolving graphs satisfying finely-tuned temporal constraints specified by the user.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2098758610",
                    "name": "Karim Alami"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "1685621",
                    "name": "E. Nguifo"
                }
            ]
        },
        {
            "paperId": "3edf20c15e21e1d583556c4f8d0b1d0f85e00ca0",
            "title": "EGG: A Framework for Generating Evolving RDF Graphs",
            "abstract": "We demonstrate EGG (Evolving Graph Generator), an open-source framework for generating evolving RDF graphs based on finely-tuned temporal constraints given by the user. During the demonstration, we will showcase the highly-expressive constraints that the user can specify in EGG to generate evolving graphs over various real-world use cases, the accuracy and scalability of the generator, and the ease of using EGG in performance comparisons of evolving graph processing systems.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2098758610",
                    "name": "Karim Alami"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "1685621",
                    "name": "E. Nguifo"
                }
            ]
        },
        {
            "paperId": "b1cadf4f8249ad5c9a34ff8d55ec50ce7fdad72e",
            "title": "Secure Matrix Multiplication with MapReduce",
            "abstract": "The MapReduce programming paradigm allows to process big data sets in parallel on a large cluster of commodity machines. The MapReduce users often outsource their data and computations to a public cloud provider. We focus on the fundamental problem of matrix multiplication, and address the inherent security and privacy concerns that occur when outsourcing to a public cloud. Our goal is to enhance the two state-of-the-art algorithms for MapReduce matrix multiplication with privacy guarantees such as: none of the nodes storing an input matrix can learn the other input matrix or the output matrix, and moreover, none of the nodes computing an intermediate result can learn the input or the output matrices. To achieve our goal, we rely on the well-known Paillier's cryptosystem and we use its partially homomorphic property to develop efficient algorithms that satisfy our problem statement. We develop two different approaches called Secure-Private (SP) and Collision-Resistant-Secure-Private (CRSP), and compare their trade-offs with respect to three fundamental criteria: computation cost, communication cost, and privacy guarantees. Finally, we give security proofs of our protocols.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "3399390",
                    "name": "Xavier Bultel"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "153528762",
                    "name": "Matthieu Giraud"
                },
                {
                    "authorId": "3438430",
                    "name": "P. Lafourcade"
                }
            ]
        },
        {
            "paperId": "c98225393c1c67bda49d9dad144ed1e84ed93b65",
            "title": "gMark: Schema-Driven Generation of Graphs and Queries",
            "abstract": "Abstract-Massive graph data sets are pervasive in contemporary application domains. Hence, graph database systems are becoming increasingly important. In the experimental study of these systems, it is vital that the research community has shared solutions for the generation of database instances and query workloads having predictable and controllable properties. We present the design and engineering principles of gMark, a domain- and query language-independent graph instance and query workload generator. A core contribution of gMark is its ability to target and control the diversity of properties of both the generated instances and the generated workloads coupled to these instances. Further novelties include support for regular path queries, a fundamental graph query paradigm, and schema-driven selectivity estimation of queries, a key feature in controlling workload chokepoints. We illustrate the flexibility and practical usability of gMark by showcasing the framework\u2019s capabilities in generating high quality graphs and workloads, and its ability to encode user-defined schemas across a variety of application domains.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2856719",
                    "name": "Guillaume Bagan"
                },
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "145301017",
                    "name": "G. Fletcher"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                },
                {
                    "authorId": "1903798",
                    "name": "N. Advokaat"
                }
            ]
        },
        {
            "paperId": "0daa156e7b4168df25733ce58680dd15b539fa50",
            "title": "Generating Flexible Workloads for Graph Databases",
            "abstract": "Graph data management tools are nowadays evolving at a great pace. Key drivers of progress in the design and study of data intensive systems are solutions for synthetic generation of data and workloads, for use in empirical studies. Current graph generators, however, provide limited or no support for workload generation or are limited to fixed use-cases. Towards addressing these limitations, we demonstrate gMark, the first domain- and query language-independent framework for synthetic graph and query workload generation. Its novel features are: (i) fine-grained control of graph instance and query workload generation via expressive user-defined schemas; (ii) the support of expressive graph query languages, including recursion among other features; and, (iii) selectivity estimation of the generated queries. During the demonstration, we will showcase the highly tunable generation of graphs and queries through various user-defined schemas and targeted selectivities, and the variety of supported practical graph query languages. We will also show a performance comparison of four state-of-the-art graph database engines, which helps us understand their current strengths and desirable future extensions.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2856719",
                    "name": "Guillaume Bagan"
                },
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "145301017",
                    "name": "G. Fletcher"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                },
                {
                    "authorId": "1903798",
                    "name": "N. Advokaat"
                }
            ]
        },
        {
            "paperId": "2b501cd956dabeea876a82dc73a72837fb34a0aa",
            "title": "Learning Linear Regression Models over Factorized Joins",
            "abstract": "We investigate the problem of building least squares regression models over training datasets defined by arbitrary join queries on database tables. Our key observation is that joins entail a high degree of redundancy in both computation and data representation, which is not required for the end-to-end solution to learning over joins. We propose a new paradigm for computing batch gradient descent that exploits the factorized computation and representation of the training datasets, a rewriting of the regression objective function that decouples the computation of cofactors of model parameters from their convergence, and the commutativity of cofactor computation with relational union and projection. We introduce three flavors of this approach: F/FDB computes the cofactors in one pass over the materialized factorized join; Favoids this materialization and intermixes cofactor and join computation; F/SQL expresses this mixture as one SQL query. Our approach has the complexity of join factorization, which can be exponentially lower than of standard joins. Experiments with commercial, public, and synthetic datasets show that it outperforms MADlib, Python StatsModels, and R, by up to three orders of magnitude.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "3416110",
                    "name": "Maximilian Schleich"
                },
                {
                    "authorId": "1756801",
                    "name": "Dan Olteanu"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                }
            ]
        },
        {
            "paperId": "c407208614840eea238587f65f71dbda95002e26",
            "title": "Learning Join Queries from User Examples",
            "abstract": "We investigate the problem of learning join queries from user examples. The user is presented with a set of candidate tuples and is asked to label them as positive or negative examples, depending on whether or not she would like the tuples as part of the join result. The goal is to quickly infer an arbitrary n-ary join predicate across an arbitrary number m of relations while keeping the number of user interactions as minimal as possible. We assume no prior knowledge of the integrity constraints across the involved relations. Inferring the join predicate across multiple relations when the referential constraints are unknown may occur in several applications, such as data integration, reverse engineering of database queries, and schema inference. In such scenarios, the number of tuples involved in the join is typically large. We introduce a set of strategies that let us inspect the search space and aggressively prune what we call uninformative tuples, and we directly present to the user the informative ones\u2014that is, those that allow the user to quickly find the goal query she has in mind. In this article, we focus on the inference of joins with equality predicates and also allow disjunctive join predicates and projection in the queries. We precisely characterize the frontier between tractability and intractability for the following problems of interest in these settings: consistency checking, learnability, and deciding the informativeness of a tuple. Next, we propose several strategies for presenting tuples to the user in a given order that allows minimization of the number of interactions. We show the efficiency of our approach through an experimental study on both benchmark and synthetic datasets.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "2573120",
                    "name": "S. Staworko"
                }
            ]
        },
        {
            "paperId": "05a72f700e774922dd14dfadbe6b33c0f2127565",
            "title": "Graph Data Exchange with Target Constraints",
            "abstract": "Data exchange is the problem of translating data structured under a source schema according to a target schema and a set of source-to-target constraints known as schema mappings. In this paper, we investigate the problem of data exchange in a heterogeneous setting, where the source is a relational database, the target is a graph database, and the schema mappings are defined across them. We study the classical problems considered in data exchange, namely the existence of solutions and query answering. We show that both problems are intractable in the presence of target constraints, already under significant restrictions.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2634072",
                    "name": "Iovka Boneva"
                },
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                }
            ]
        },
        {
            "paperId": "0e9882f5d9a4c0ee873f7806ffe645b0473377a7",
            "title": "Interactive Path Query Specification on Graph Databases",
            "abstract": "Graph databases are becoming pervasive in several application scenarios such as the Semantic Web, social and biological networks, and geographical databases, to name a few. However, specifying a graph query is a cumbersome task for non-expert users because graph databases (i) are usually of large size hence difficult to visualize and (ii) do not carry proper metadata as there is no clear distinction between the instances and the schemas. We present GPS, a system for interactive path query specification on graph databases, which assists the user to specify path queries defined by regular expressions. The user is interactively asked to visualize small fragments of the graph and to label nodes of interest as positive or negative, depending on whether or not she would like the nodes as part of the query result. After each interaction, the system prunes the uninformative nodes i.e., those that do not add any information about the user's goal query. Thus, the system also guides the user to specify her goal query with a minimal number of interactions.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                }
            ]
        },
        {
            "paperId": "2529bb021fda27e1b4012ea62d68c26fd53efcd3",
            "title": "Learning Path Queries on Graph Databases",
            "abstract": "We investigate the problem of learning graph queries by exploiting user examples. The input consists of a graph database in which the user has labeled a few nodes as positive or negative examples, depending on whether or not she would like the nodes as part of the query result. Our goal is to handle such examples to find a query whose output is what the user expects. This kind of scenario is pivotal in several application settings where unfamiliar users need to be assisted to specify their queries. In this paper, we focus on path queries defined by regular expressions, we identify fundamental difficulties of our problem setting, we formalize what it means to be learnable, and we prove that the class of queries under study enjoys this property. We additionally investigate an interactive scenario where we start with an empty set of examples and we identify the informative nodes i.e., those that contribute to the learning process. Then, we ask the user to label these nodes and iterate the learning process until she is satisfied with the learned query. Finally, we present an experimental study on both real and synthetic datasets devoted to gauging the effectiveness of our learning algorithm and the improvement of the interactive approach.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                }
            ]
        },
        {
            "paperId": "3100410dac4b43d7d5016a579560c3877e3e63ee",
            "title": "The iBench Integration Metadata Generator",
            "abstract": "Given the maturity of the data integration field it is surprising that rigorous empirical evaluations of research ideas are so scarce. We identify a major roadblock for empirical work - the lack of comprehensive metadata generators that can be used to create benchmarks for different integration tasks. This makes it difficult to compare integration solutions, understand their generality, and understand their performance. We present iBench, the first metadata generator that can be used to evaluate a wide-range of integration tasks (data exchange, mapping creation, mapping composition, schema evolution, among many others). iBench permits control over the size and characteristics of the metadata it generates (schemas, constraints, and mappings). Our evaluation demonstrates that iBench can efficiently generate very large, complex, yet realistic scenarios with different characteristics. We also present an evaluation of three mapping creation systems using iBench and show that the intricate control that iBench provides over metadata scenarios can reveal new and important empirical insights. iBench is an open-source, extensible tool that we are providing to the community. We believe it will raise the bar for empirical evaluation and comparison of data integration systems.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2983610",
                    "name": "Patricia C. Arocena"
                },
                {
                    "authorId": "1798930",
                    "name": "Boris Glavic"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "2110417078",
                    "name": "Ren\u00e9e J. Miller"
                }
            ]
        },
        {
            "paperId": "31b63d505dbf6f2b9a60d0c45976f2cbd5cd9619",
            "title": "gMark: Schema-Driven Generation of Graphs and Queries",
            "abstract": "Massive graph data sets are pervasive in contemporary application domains. Hence, graph database systems are becoming increasingly important. In the experimental study of these systems, it is vital that the research community has shared solutions for the generation of database instances and query workloads having predictable and controllable properties. In this paper, we present the design and engineering principles of <inline-formula> <tex-math notation=\"LaTeX\">$\\mathsf {gMark}$</tex-math><alternatives> <inline-graphic xlink:href=\"ciucanu-ieq1-2633993.gif\"/></alternatives></inline-formula>, a domain- and query language-independent graph instance and query workload generator. A core contribution of <inline-formula> <tex-math notation=\"LaTeX\">$\\mathsf {gMark}$</tex-math><alternatives> <inline-graphic xlink:href=\"ciucanu-ieq2-2633993.gif\"/></alternatives></inline-formula> is its ability to target and control the diversity of properties of both the generated instances and the generated workloads coupled to these instances. Further novelties include support for regular path queries, a fundamental graph query paradigm, and schema-driven selectivity estimation of queries, a key feature in controlling workload chokepoints. We illustrate the flexibility and practical usability of <inline-formula><tex-math notation=\"LaTeX\">$\\mathsf {gMark}$ </tex-math><alternatives><inline-graphic xlink:href=\"ciucanu-ieq3-2633993.gif\"/></alternatives></inline-formula> by showcasing the framework's capabilities in generating high quality graphs and workloads, and its ability to encode user-defined schemas across a variety of application domains.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2856719",
                    "name": "Guillaume Bagan"
                },
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "145301017",
                    "name": "G. Fletcher"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                },
                {
                    "authorId": "1903798",
                    "name": "N. Advokaat"
                }
            ]
        },
        {
            "paperId": "43f33058302aae7ce3871884b01d1a33d799ebf2",
            "title": "gMark: Controlling Workload Diversity in Benchmarking Graph Databases",
            "abstract": "Massive graph data sets are pervasive in contemporary application domains. Hence, graph database systems are becoming increasingly important. In the study of these systems, it is vital that the research community has shared benchmarking solutions for the generation of database instances and query workloads having predictable and controllable properties. Similarly to TPC benchmarks for relational databases, benchmarks for graph databases have been important drivers for the Semantic Web and graph data management communities. In this paper, we present the design and engineering principles of gMark, a domain- and query language-independent graph benchmark exhibiting flexible schema and workload chokepoints. A core contribution of gMark is its ability to target and control the diversity of properties of both the generated graph instances and the generated query workloads coupled to these instances. A further novelty is the support of recursive regular path queries, a fundamental graph query paradigm. We illustrate the flexibility and practical usability of gMark by showcasing the framework's capabilities in generating high quality graphs and workloads, and its ability to encode user-defined schemas across a variety of application domains.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2856719",
                    "name": "Guillaume Bagan"
                },
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "145301017",
                    "name": "G. Fletcher"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                },
                {
                    "authorId": "1903798",
                    "name": "N. Advokaat"
                }
            ]
        },
        {
            "paperId": "5145da0a181c8539f0c6b4e0eb5745febf97d84c",
            "title": "Gain Control over your Integration Evaluations",
            "abstract": "Integration systems are typically evaluated using a few real-world scenarios (e.g., bibliographical or biological datasets) or using synthetic scenarios (e.g., based on star-schemas or other patterns for schemas and constraints). Reusing such evaluations is a cumbersome task because their focus is usually limited to showcasing a specific feature of an approach. This makes it difficult to compare integration solutions, understand their generality, and understand their performance for different application scenarios. Based on this observation, we demonstrate some of the requirements for developing integration benchmarks. We argue that the major abstractions used for integration problems have converged in the last decade which enables the application of robust empirical methods to integration problems (from schema evolution, to data exchange, to answering queries using views and many more). Specifically, we demonstrate that schema mappings are the main abstraction that now drives most integration solutions and show how a metadata generator can be used to create more credible evaluations of the performance and scalability of data integration systems. We will use the demonstration to evangelize for more robust, shared empirical evaluations of data integration systems.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2983610",
                    "name": "Patricia C. Arocena"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "1798930",
                    "name": "Boris Glavic"
                },
                {
                    "authorId": "2110417078",
                    "name": "Ren\u00e9e J. Miller"
                }
            ]
        },
        {
            "paperId": "62930219cc8533bef7d6588c4ab9c386c4ab4872",
            "title": "Cross-Model Queries and Schemas: Complexity and Learning. (Requ\u00eates et Sch\u00e9mas H\u00e9t\u00e9rog\u00e8nes : Complexit\u00e9 et Apprentissage)",
            "abstract": "Specifying a database query using a formal query language is typically a challenging task for non-expert users. In the context of big data, this problem becomes even harder because it requires the users to deal with database instances of large size and hence difficult to visualize. Such instances usually lack a schema to help the users specify their queries, or have an incomplete schema as they come from disparate data sources. In this thesis, we address the problem of query specification for non-expert users. We identify two possible approaches for tackling this problem: learning queries from examples and translating the data in a format that the user finds easier to query. Our contributions are aligned with these two complementary directions and span over three of the most popular data models: XML, relational, and graph. This thesis consists of two parts, dedicated to (i) schema definition and translation, and to (ii) learning schemas and queries. In the first part, we define schema formalisms for unordered XML and we analyze their computational properties; we also study the complexity of the data exchange problem in the setting of a relational source and a graph target database. In the second part, we investigate the problem of learning from examples the schemas for unordered XML proposed in the first part, as well as relational join queries and path queries on graph databases. The interactive scenario that we propose for these two classes of queries is immediately applicable to assisting non-expert users in the process of query specification.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                }
            ]
        },
        {
            "paperId": "a5170eb87547140ee2e9d89e12e49e64b5f1f7d5",
            "title": "Controlling Diversity in Benchmarking Graph Databases",
            "abstract": "Massive graph data sets are pervasive in contemporary application domains. Hence, graph database systems are becoming increasingly important. In the study of these systems , it is vital that the research community has shared benchmarking solutions for the generation of database instances and query workloads having predictable and con-trollable properties. Similarly to TPC benchmarks for re-lational databases, benchmarks for graph databases have been important drivers for the Semantic Web and graph data management communities. Current benchmarks, however , are either limited to fixed graphs or graph schemas, or provide limited or no support for generating tailored query workloads to accompany graph instances. To move the community forward, a benchmarking approach which overcomes these limitations is crucial. In this paper, we present the design and engineering principles of gMark, a domain-and query language-independent graph benchmark addressing these limitations of current solutions. A core contribution of gMark is its ability to target and control the diversity of properties of both the generated graph instances and the generated query workloads coupled to these instances. A further novelty is the support of recursive regular path queries, a fundamental graph query paradigm. We illustrate the flexibility and practical usability of gMark by showcas-ing the framework's capabilities in generating high quality graphs and workloads, and its ability to encode user-defined schemas across a variety of application domains.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2856719",
                    "name": "Guillaume Bagan"
                },
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "145301017",
                    "name": "G. Fletcher"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                },
                {
                    "authorId": "1903798",
                    "name": "N. Advokaat"
                }
            ]
        },
        {
            "paperId": "279fa8ca69c237ba40c77dff6626d856e25090bc",
            "title": "A Paradigm for Learning Queries on Big Data",
            "abstract": "Specifying a database query using a formal query language is typically a challenging task for non-expert users. In the context of big data, this problem becomes even harder as it requires the users to deal with database instances of big sizes and hence difficult to visualize. Such instances usually lack a schema to help the users specify their queries, or have an incomplete schema as they come from disparate data sources. In this paper, we propose a novel paradigm for interactive learning of queries on big data, without assuming any knowledge of the database schema. The paradigm can be applied to different database models and a class of queries adequate to the database model. In particular, in this paper we present two instantiations that validated the proposed paradigm for learning relational join queries and for learning path queries on graph databases. Finally, we discuss the challenges of employing the paradigm for further data models and for learning cross-model schema mappings.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "48035814",
                    "name": "Aur\u00e9lien Lemay"
                },
                {
                    "authorId": "2573120",
                    "name": "S. Staworko"
                }
            ]
        },
        {
            "paperId": "7ea79b124bbfc02f68051533a76fb96d4e1a9fc1",
            "title": "Interactive Join Query Inference with JIM",
            "abstract": "Specifying join predicates may become a cumbersome task in many situations e.g., when the relations to be joined come from disparate data sources, when the values of the attributes carry little or no knowledge of metadata, or simply when the user is unfamiliar with querying formalisms. Such task is recurrent in many traditional data management applications, such as data integration, constraint inference, and database denormalization, but it is also becoming pivotal in novel crowdsourcing applications. We present Jim (Join Inference Machine), a system for interactive join specification tasks, where the user infers an n-ary join predicate by selecting tuples that are part of the join result via Boolean membership queries. The user can label tuples as positive or negative, while the system allows to identify and gray out the uninformative tuples i.e., those that do not add any information to the final learning goal. The tool also guides the user to reach her join inference goal with a minimal number of interactions.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "2573120",
                    "name": "S. Staworko"
                }
            ]
        },
        {
            "paperId": "b6342792f8c6c6ec2c92c51f8a720c47cff99bb2",
            "title": "Interactive Inference of Join Queries",
            "abstract": "We investigate the problem of inferring join queries from user interactions. The user is presented with a set of candidate tuples and is asked to label them as positive or negative depending on whether or not she would like the tuples as part of the join result. The goal is to quickly infer an arbitrary n-ary join predicate across two relations by keeping the number of user interactions as minimal as possible. We assume no prior knowledge of the integrity constraints between the involved relations. This kind of scenario occurs in several application settings, such as data integration, reverse engineering of database queries, and constraint inference. In such scenarios, the database instances may be too big to be skimmed. We explore the search space by using a set of strategies that let us prune what we call \\uninformative\" tuples, and directly present to the user the informative ones i.e., those that allow to quickly nd the goal query that the user has in mind. In this paper, we focus on the inference of joins with equality predicates and we show that for such joins deciding whether a tuple is uninformative can be done in polynomial time. Next, we propose several strategies for presenting tuples to the user in a given order that lets minimize the number of interactions. We show the eciency and scalability of our approach through an experimental study on both benchmark and synthetic datasets. Finally, we prove that adding projection to our queries makes the problem intractable.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "2573120",
                    "name": "S. Staworko"
                }
            ]
        },
        {
            "paperId": "3541455f3e8ad933ce4b0aef4fa1beaf73a316e1",
            "title": "Learning Schemas for Unordered XML",
            "abstract": "We consider unordered XML, where the relative order among siblings is ignored, and we investigate the problem of learning schemas from examples given by the user. We focus on the schema formalisms proposed in [10]: disjunctive multiplicity schemas (DMS) and its restriction, disjunction-free multiplicity schemas (MS). A learning algorithm takes as input a set of XML documents which must satisfy the schema (i.e., positive examples) and a set of XML documents which must not satisfy the schema (i.e., negative examples), and returns a schema consistent with the examples. We investigate a learning framework inspired by Gold [18], where a learning algorithm should be sound i.e., always return a schema consistent with the examples given by the user, and complete i.e., able to produce every schema with a sufficiently rich set of examples. Additionally, the algorithm should be efficienti.e., polynomial in the size of the input. We prove that the DMS are learnable from positive examples only, but they are not learnable when we also allow negative examples. Moreover, we show that the MS are learnable in the presence of positive examples only, and also in the presence of both positive and negative examples. Furthermore, for the learnable cases, the proposed learning algorithms return minimal schemas consistent with the examples.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "2573120",
                    "name": "S. Staworko"
                }
            ]
        },
        {
            "paperId": "56a9429f401d278ffac9ba97d66cee137f9660b1",
            "title": "Learning queries for relational, semi-structured, and graph databases",
            "abstract": "Web applications store their data within various database models, such as relational, semi-structured, and graph data models to name a few. We study learning algorithms for queries for the above mentioned models. As a further goal, we aim to apply the results to learning cross-model database mappings, which can also be seen as queries across different schemas.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                }
            ]
        },
        {
            "paperId": "88192796376f0708281665df73561cd15e41b2e1",
            "title": "Simple Schemas for Unordered XML",
            "abstract": "We consider unordered XML, where the relative order among siblings is ignored, and propose two simple yet practical schema formalisms: disjunctive multiplicity schemas (DMS), and its restriction, disjunction-free multiplicity schemas (MS). We investigate their computational properties and characterize the complexity of the following static analysis problems: schema satisfiability, membership of a tree to the language of a schema, schema containment, twig query satisfiability, implication, and containment in the presence of schema. Our research indicates that the proposed formalisms retain much of the expressiveness of DTDs without an increase in computational complexity.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2634072",
                    "name": "Iovka Boneva"
                },
                {
                    "authorId": "1850588",
                    "name": "Radu Ciucanu"
                },
                {
                    "authorId": "2573120",
                    "name": "S. Staworko"
                }
            ]
        }
    ]
}