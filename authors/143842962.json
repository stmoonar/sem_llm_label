{
    "authorId": "143842962",
    "papers": [
        {
            "paperId": "38e80ecf905f74e734f8177f663310ac74072a99",
            "title": "PG-Schema: Schemas for Property Graphs",
            "abstract": "Property graphs have reached a high level of maturity, witnessed by multiple robust graph database systems as well as the ongoing ISO standardization effort aiming at creating a new standard Graph Query Language (GQL). Yet, despite documented demand, schema support is limited both in existing systems and in the first version of the GQL Standard. It is anticipated that the second version of the GQL Standard will include a rich DDL. Aiming to inspire the development of GQL and enhance the capabilities of graph database systems, we propose PG-Schema, a simple yet powerful formalism for specifying property graph schemas. It features PG-Schema with flexible type definitions supporting multi-inheritance, as well as expressive constraints based on the recently proposed PG-Keys formalism. We provide the formal syntax and semantics of PG-Schema, which meet principled design requirements grounded in contemporary property graph management scenarios, and offer a detailed comparison of its features with those of existing schema languages and graph database systems.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "31359282",
                    "name": "Stefania Dumbrava"
                },
                {
                    "authorId": "145301017",
                    "name": "G. Fletcher"
                },
                {
                    "authorId": "1687456",
                    "name": "J. Hidders"
                },
                {
                    "authorId": "2109133959",
                    "name": "Bei Li"
                },
                {
                    "authorId": "1681226",
                    "name": "L. Libkin"
                },
                {
                    "authorId": "144352362",
                    "name": "W. Martens"
                },
                {
                    "authorId": "3166093",
                    "name": "Filip Murlak"
                },
                {
                    "authorId": "2748632",
                    "name": "Stefan Plantikow"
                },
                {
                    "authorId": "2191632710",
                    "name": "Ognjen Savkovi'c"
                },
                {
                    "authorId": "1703204",
                    "name": "Juan Sequeda"
                },
                {
                    "authorId": "2573120",
                    "name": "S. Staworko"
                },
                {
                    "authorId": "1777646",
                    "name": "Dominik Tomaszuk"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "2163451214",
                    "name": "Domagoj Vrgovc"
                },
                {
                    "authorId": "1738190",
                    "name": "Mingxi Wu"
                }
            ]
        },
        {
            "paperId": "131b6e4f803cf5fb3df947132cf8c731065881d5",
            "title": "Semantic Foundations of Seraph Continuous Graph Query Language",
            "abstract": "The scientific community has been studying graph data models for decades. Their high expressiveness and elasticity led the scientific community to design a variety of graph data models and graph query languages, and the practitioners to use them to model real-world cases and extract useful information. Recently, property graphs and, in particular, Cypher 9 (the first open version of the well-known Neo4j Inc.'s language) are gaining popularity. Practitioners find Cypher useful and applicable in many scenarios. However, we are living in a streaming world where data continuously flows. A growing number of Cypher's users show interest in continuously querying graph data to act in a timely fashion. Indeed, Cypher lacks the features for dealing with streams of (graph) data and continuous query evaluation. In this work, we propose Seraph, an extension of Cypher, as a first attempt to introduce streaming features in the context of property graph query languages. Specifically, we define Seraph semantics, we propose a first version of Seraph syntax, and we discuss the potential impacts from a user perspective.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "49383451",
                    "name": "E. Falzone"
                },
                {
                    "authorId": "50271459",
                    "name": "Riccardo Tommasini"
                },
                {
                    "authorId": "2539248",
                    "name": "Emanuele Della Valle"
                },
                {
                    "authorId": "2341999",
                    "name": "P. Selmer"
                },
                {
                    "authorId": "2748632",
                    "name": "Stefan Plantikow"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "2086941899",
                    "name": "Keith W. Hare"
                },
                {
                    "authorId": "98517665",
                    "name": "Ljubica Lazarevic"
                },
                {
                    "authorId": "31846192",
                    "name": "Tobias Lindaaker"
                }
            ]
        },
        {
            "paperId": "d4408e4e99c74913c7bf4b7a0aacf5bf67557c96",
            "title": "Graph Pattern Matching in GQL and SQL/PGQ",
            "abstract": "As graph databases become widespread, the International Organization for Standardization (ISO) and International Electrotechnical Commission (IEC) have approved a project to create GQL, a standard property graph query language. This complements the SQL/PGQ project, which specifies how to define graph views over a SQL tabular schema, and to run read-only queries against them. Both projects have been assigned to the ISO/IEC JTC1 SC32 working group for Database Languages, WG3, which continues to maintain and enhance SQL as a whole. This common responsibility helps enforce a policy that the identical core of both PGQ and GQL is a graph pattern matching sub-language, here termed GPML. The WG3 design process is also analyzed by an academic working group, part of the Linked Data Benchmark Council (LDBC), whose task is to produce a formal semantics of these graph data languages, which complements their standard specifications. This paper, written by members of WG3 and LDBC, presents the key elements of the GPML of SQL/PGQ and GQL in advance of the publication of these new standards.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "50136367",
                    "name": "Alin Deutsch"
                },
                {
                    "authorId": "2438650",
                    "name": "Nadime Francis"
                },
                {
                    "authorId": "49061836",
                    "name": "Alastair Green"
                },
                {
                    "authorId": "2086941899",
                    "name": "Keith W. Hare"
                },
                {
                    "authorId": "2109133959",
                    "name": "Bei Li"
                },
                {
                    "authorId": "1681226",
                    "name": "L. Libkin"
                },
                {
                    "authorId": "31846192",
                    "name": "Tobias Lindaaker"
                },
                {
                    "authorId": "1894887",
                    "name": "Victor Marsault"
                },
                {
                    "authorId": "144352362",
                    "name": "W. Martens"
                },
                {
                    "authorId": "145434635",
                    "name": "Jan-Eike Michels"
                },
                {
                    "authorId": "3166093",
                    "name": "Filip Murlak"
                },
                {
                    "authorId": "2748632",
                    "name": "Stefan Plantikow"
                },
                {
                    "authorId": "2341999",
                    "name": "P. Selmer"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "3159707",
                    "name": "O. V. Rest"
                },
                {
                    "authorId": "2434366",
                    "name": "D. Vrgo\u010d"
                },
                {
                    "authorId": "1738190",
                    "name": "Mingxi Wu"
                },
                {
                    "authorId": "31852156",
                    "name": "F. Zemke"
                }
            ]
        },
        {
            "paperId": "8f973517436e21e4e6f54b37837a9f6681d06265",
            "title": "The future is big graphs",
            "abstract": "Ensuring the success of big graph processing for the next decade and beyond.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1783693",
                    "name": "Sherif Sakr"
                },
                {
                    "authorId": "1699192",
                    "name": "A. Bonifati"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "1760940",
                    "name": "A. Iosup"
                },
                {
                    "authorId": "150169694",
                    "name": "Khaled Ammar"
                },
                {
                    "authorId": "2772109",
                    "name": "Renzo Angles"
                },
                {
                    "authorId": "1709661",
                    "name": "W. Aref"
                },
                {
                    "authorId": "144658846",
                    "name": "M. Arenas"
                },
                {
                    "authorId": "2919642",
                    "name": "Maciej Besta"
                },
                {
                    "authorId": "1687211",
                    "name": "P. Boncz"
                },
                {
                    "authorId": "2176381",
                    "name": "K. Daudjee"
                },
                {
                    "authorId": "2539248",
                    "name": "Emanuele Della Valle"
                },
                {
                    "authorId": "31359282",
                    "name": "Stefania Dumbrava"
                },
                {
                    "authorId": "1699014",
                    "name": "O. Hartig"
                },
                {
                    "authorId": "1679379",
                    "name": "Bernhard Haslhofer"
                },
                {
                    "authorId": "2290758",
                    "name": "T. Hegeman"
                },
                {
                    "authorId": "1687456",
                    "name": "J. Hidders"
                },
                {
                    "authorId": "1682407",
                    "name": "K. Hose"
                },
                {
                    "authorId": "1986996",
                    "name": "Adriana Iamnitchi"
                },
                {
                    "authorId": "1993949",
                    "name": "Vasiliki Kalavri"
                },
                {
                    "authorId": "2035501761",
                    "name": "Hugo Kapp"
                },
                {
                    "authorId": "144352362",
                    "name": "W. Martens"
                },
                {
                    "authorId": "9107867",
                    "name": "M. Tamer Ozsu"
                },
                {
                    "authorId": "2065161",
                    "name": "E. Peukert"
                },
                {
                    "authorId": "2748632",
                    "name": "Stefan Plantikow"
                },
                {
                    "authorId": "2065777089",
                    "name": "Mohamed Ragab"
                },
                {
                    "authorId": "1747805",
                    "name": "M. Ripeanu"
                },
                {
                    "authorId": "1783781",
                    "name": "S. Salihoglu"
                },
                {
                    "authorId": "40262967",
                    "name": "Christian Schulz"
                },
                {
                    "authorId": "2341999",
                    "name": "P. Selmer"
                },
                {
                    "authorId": "1703204",
                    "name": "Juan Sequeda"
                },
                {
                    "authorId": "2766552",
                    "name": "Joshua Shinavier"
                },
                {
                    "authorId": "2073266386",
                    "name": "G'abor Sz'arnyas"
                },
                {
                    "authorId": "50271459",
                    "name": "Riccardo Tommasini"
                },
                {
                    "authorId": "2606269",
                    "name": "Antonino Tumeo"
                },
                {
                    "authorId": "2860260",
                    "name": "Alexandru Uta"
                },
                {
                    "authorId": "1784556",
                    "name": "A. Varbanescu"
                },
                {
                    "authorId": "2702080",
                    "name": "Hsiang-Yun Wu"
                },
                {
                    "authorId": "2967413",
                    "name": "N. Yakovets"
                },
                {
                    "authorId": "144157459",
                    "name": "D. Yan"
                },
                {
                    "authorId": "2004672",
                    "name": "Eiko Yoneki"
                }
            ]
        },
        {
            "paperId": "2b519f3ec796f6fb5cad8d766e57e3fcf7ac8d7b",
            "title": "Conjunctive Queries with Theta Joins Under Updates",
            "abstract": "Modern application domains such as Composite Event Recognition (CER) and real-time Analytics require the ability to dynamically refresh query results under high update rates. Traditional approaches to this problem are based either on the materialization of subresults (to avoid their recomputation) or on the recomputation of subresults (to avoid the space overhead of materialization). Both techniques have recently been shown suboptimal: instead of materializing results and subresults, one can maintain a data structure that supports efficient maintenance under updates and can quickly enumerate the full query output, as well as the changes produced under single updates. Unfortunately, these data structures have been developed only for aggregate-join queries composed of equi-joins, limiting their applicability in domains such as CER where temporal joins are commonplace. In this paper, we present a new approach for dynamically evaluating queries with multi-way theta-joins under updates that is effective in avoiding both materialization and recomputation of results, while supporting a wide range of applications. To do this we generalize Dynamic Yannakakis, an algorithm for dynamically processing acyclic equi-join queries. In tandem, and of independent interest, we generalize the notions of acyclicity and free-connexity to arbitrary theta-joins and show how to compute corresponding join trees. We instantiate our framework to the case where theta-joins are only composed of equalities and inequalities and experimentally compare our algorithm to state of the art CER systems as well as incremental view maintenance engines. Our approach performs consistently better than the competitor systems with up to two orders of magnitude improvements in both time and memory consumption.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2059322882",
                    "name": "Muhammad Idris"
                },
                {
                    "authorId": "144739409",
                    "name": "M. Ugarte"
                },
                {
                    "authorId": "1709642",
                    "name": "Stijn Vansummeren"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "7337091",
                    "name": "Wolfgang Lehner"
                }
            ]
        },
        {
            "paperId": "2ee6132a71efc2e869bb5a68e21d039f74d6e78a",
            "title": "Understanding Trolls with Efficient Analytics of Large Graphs in Neo4j",
            "abstract": ": Analytics of large graph data set has become an important means of understanding and influencing the world. The use of graph database technology in the International Consortium of Investigative Journalists\u2019 (ICIJ) investigation of the Panama Papers and Paradise Papers or in cancer research illustrates how analysing graph-structured data helps to uncover important but hidden relationships. A very current example in that regards shows how graph analytics can help shed light on the operations of social media troll-networks, e.g. on Twitter. In similar fashion, graph analytics can help enterprises to unearth hidden patterns and structures within connected data, to make more accurate predictions and faster decisions. All this requires efficient graph analytics well-integrated with management of graph data. The Neo4j Graph Platform provides such an environment. It provides transactional processing and analytical processing of graph data including data management and analytics tooling. A central element for graph analytics in the Graph Platform are the Neo4j graph algorithms. Neo4j graph algorithms provide efficiently implemented, parallel versions of common graph algorithms, integrated and optimized for the Neo4j transactional database. In this paper, we will describe the design and integration Neo4j Graph Algorithms, demonstrate its utility of our approach with a Twitter Troll analysis, and show case its performance with a few experiments on large graphs.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2083606109",
                    "name": "David Allen"
                },
                {
                    "authorId": "92211234",
                    "name": "A. Hodler"
                },
                {
                    "authorId": "2076041477",
                    "name": "Michael Hunger"
                },
                {
                    "authorId": "35144779",
                    "name": "Martin Knobloch"
                },
                {
                    "authorId": "2060012353",
                    "name": "W. Lyon"
                },
                {
                    "authorId": "2056759195",
                    "name": "Mark Needham"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                }
            ]
        },
        {
            "paperId": "63f911701bf9262b1927a28da6ea600238c1b1ce",
            "title": "Period Index: A Learned 2D Hash Index for Range and Duration Queries",
            "abstract": "Today, most commercial database systems provide some support for the management of temporal data, but the index support for efficiently accessing such data is rather limited. Existing access paths neglect the fact that time intervals are located on the timeline and have a duration, two important pieces of information for querying temporal data. In this paper, we tackle this problem and introduce a novel index structure, termed Period Index, for efficiently accessing temporal data based on these two pieces of information. The index supports temporal queries that constrain the position of an interval on the timeline (range queries), its interval duration (duration queries), or both (range-duration queries). The key idea of the new index is to split the timeline into fixed-length buckets, each of which is divided into a set of cells that are organized in levels. The cells encode the position of intervals on the timeline, whereas the levels encode their duration. This grid-based index is well-suited for parallelization and non-uniform memory access (NUMA) architectures as it is common for modern hardware with large main-memories and multi-core servers. The Period Index is independent of the physical order of the data and has predictable performance due to the underlying hashing approach. We also propose an enhanced version of our index structure, termed Period Index*, which continuously adapts the optimal bucket length to the distribution of the data. Our experiments show that Period Index* significantly beats other indexes for the class of queries that constrain both the position and the length of the time intervals, and it is competitive for queries that involve solely one temporal dimension.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "3193518",
                    "name": "Andreas Behrend"
                },
                {
                    "authorId": "1679309",
                    "name": "Anton Dign\u00f6s"
                },
                {
                    "authorId": "1719053",
                    "name": "J. Gamper"
                },
                {
                    "authorId": "1915789",
                    "name": "Philip Schmiegelt"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "7482585",
                    "name": "M. Rottmann"
                },
                {
                    "authorId": "34822068",
                    "name": "K. Kahl"
                }
            ]
        },
        {
            "paperId": "b8e30590ac81875a7fc4f7cfd425bd5148a72f5c",
            "title": "Updating Graph Databases with Cypher",
            "abstract": "The paper describes the present and the future of graph updates in Cypher, the language of the Neo4j property graph database and several other products. Update features include those with clear analogs in relational databases, as well as those that do not correspond to any relational op-erators. Moreover, unlike SQL, Cypher updates can be ar-bitrarily intertwined with querying clauses. After present-ing the current state of update features, we point out their shortcomings, most notably violations of atomicity and nondeterministic behavior of updates. These have not been previously known in the Cypher community. We then describe the industry-academia collaboration on designing a revised set of Cypher update operations. Based on discovered shortcomings of update features, a number of possible solutions were devised. They were presented to key Cypher users, who were given the opportunity to comment on how update features are used in real life, and on their preferences for proposed \ufb01xes. As the result of the consultation, a new set of update operations for Cypher were designed. Those led to a streamlined syntax, and eliminated the unexpected and problematic behavior that original Cypher updates exhib-ited.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "49061836",
                    "name": "Alastair Green"
                },
                {
                    "authorId": "2454799",
                    "name": "P. Guagliardo"
                },
                {
                    "authorId": "1681226",
                    "name": "L. Libkin"
                },
                {
                    "authorId": "31846192",
                    "name": "Tobias Lindaaker"
                },
                {
                    "authorId": "1894887",
                    "name": "Victor Marsault"
                },
                {
                    "authorId": "2748632",
                    "name": "Stefan Plantikow"
                },
                {
                    "authorId": "144153647",
                    "name": "M. Schuster"
                },
                {
                    "authorId": "2341999",
                    "name": "P. Selmer"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                }
            ]
        },
        {
            "paperId": "e69fcf24e2f3cdebf2f9df7b9b16da2e4e3948b4",
            "title": "Efficient Query Processing for Dynamically Changing Datasets",
            "abstract": "The ability to efficiently analyze changing data is a key requirement of many real-time analytics applications. Traditional approaches to this problem were developed around the notion of Incremental View Maintenance (IVM), and are based either on the materialization of subresults (to avoid their recomputation) or on the recomputation of subresults (to avoid the space overhead of materialization). Both techniques are suboptimal: instead of materializing results and subresults, one may also maintain a data structure that supports efficient maintenance under updates and from which the full query result can quickly be enumerated. In two previous articles, we have presented algorithms for dynamically evaluating queries that are easy to implement, efficient, and can be naturally extended to evaluate queries from a wide range of application domains. In this paper, we discuss our algorithm and its complexity, explaining the main components behind its efficiency. Finally, we show experiments that compare our algorithm to a state-of-the-art (Higher-order) IVM engine, as well as to a prominent complex event recognition engine. Our approach outperforms the competitor systems by up to two orders of magnitude in processing time, and one order in memory consumption.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2059322882",
                    "name": "Muhammad Idris"
                },
                {
                    "authorId": "144739409",
                    "name": "M. Ugarte"
                },
                {
                    "authorId": "1709642",
                    "name": "Stijn Vansummeren"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "7337091",
                    "name": "Wolfgang Lehner"
                }
            ]
        },
        {
            "paperId": "3b215a0dd571bb689598c02914af649394e18030",
            "title": "Analysis of Data Structures Involved in RPQ Evaluation",
            "abstract": "A fundamental ingredient of declarative graph query languages are regular path queries (RPQs). They provide an expressive yet compact way to match long and complex paths in a data graph by utilizing regular expressions. In this paper, we systematically explore and analyze the design space for the data structures involved in automaton-based RPQ evaluation. We consider three fundamental data structures used during RPQ processing: adjacency lists for quick neighborhood exploration, visited data structure for cycle detection, and the representation of intermediate results. We conduct an extensive experimental evaluation on realistic graph data sets and systematically investigate various alternative data structure representations and implementation variants. We show that carefully crafted data structures which exploit the access pattern of RPQs lead to reduced peak memory consumption and evaluation time.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "15152499",
                    "name": "Frank Tetzel"
                },
                {
                    "authorId": "143842962",
                    "name": "H. Voigt"
                },
                {
                    "authorId": "2587068",
                    "name": "M. Paradies"
                },
                {
                    "authorId": "1951237",
                    "name": "Romans Kasperovics"
                },
                {
                    "authorId": "7337091",
                    "name": "Wolfgang Lehner"
                }
            ]
        }
    ]
}