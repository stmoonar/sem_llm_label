{
    "authorId": "1691736",
    "papers": [
        {
            "paperId": "20f7e730cda5f933a17792cccd2260c1819f6960",
            "title": "A framework for extraction and transformation of documents",
            "abstract": "We present a theoretical framework for the extraction and transformation of text documents. We propose to use a two-phase process where the first phase extracts span-tuples from a document, and the second phase maps the content of the span-tuples into new documents. We base the extraction phase on the framework of document spanners and the transformation phase on the theory of polyregular functions, the class of regular string-to-string functions with polynomial growth. For supporting practical extract-transform scenarios, we propose an extension of document spanners described by regex formulas from span-tuples to so-called multispan-tuples, where variables are mapped to sets of spans. We prove that this extension, called regex multispanners, has the same desirable properties as standard spanners described by regex formulas. In our framework, an Extract-Transform (ET) program is given by a regex multispanner followed by a polyregular function. In this paper, we study the expressibility and evaluation problem of ET programs when the transformation function is linear, called linear ET programs. We show that linear ET programs are equally expressive as non-deterministic streaming string transducers under bag semantics. Moreover, we show that linear ET programs are closed under composition. Finally, we present an enumeration algorithm for evaluating every linear ET program over a document with linear time preprocessing and constant delay.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2302407026",
                    "name": "Cristian Riveros"
                },
                {
                    "authorId": "2302407826",
                    "name": "Markus L. Schmid"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "2ef3f30e83d62fe72a4204fded2c8148a4d10afd",
            "title": "Color Refinement for Relational Structures",
            "abstract": "Color Refinement, also known as Naive Vertex Classification, is a classical method to distinguish graphs by iteratively computing a coloring of their vertices. While it is mainly used as an imperfect way to test for isomorphism, the algorithm permeated many other, seemingly unrelated, areas of computer science. The method is algorithmically simple, and it has a well-understood distinguishing power: It is logically characterized by Cai, F\\\"urer and Immerman (1992), who showed that it distinguishes precisely those graphs that can be distinguished by a sentence of first-order logic with counting quantifiers and only two variables. A combinatorial characterization is given by Dvo\\v{r}\\'ak (2010), who shows that it distinguishes precisely those graphs that can be distinguished by the number of homomorphisms from some tree. In this paper, we introduce Relational Color Refinement (RCR, for short), a generalization of the Color Refinement method from graphs to arbitrary relational structures, whose distinguishing power admits the equivalent combinatorial and logical characterizations as Color Refinement has on graphs: We show that RCR distinguishes precisely those structures that can be distinguished by the number of homomorphisms from an acyclic relational structure. Further, we show that RCR distinguishes precisely those structures that can be distinguished by a sentence of the guarded fragment of first-order logic with counting quantifiers.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2212031884",
                    "name": "Benjamin Scheidt"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "ec92fc1d5d973269d241f6e2514e47918001e146",
            "title": "Using Color Refinement to Boost Enumeration and Counting for Acyclic CQs of Binary Schemas",
            "abstract": "We present an index structure, called the color-index, to boost the evaluation of acyclic conjunctive queries (ACQs) over binary schemas. The color-index is based on the color refinement algorithm, a widely used subroutine for graph isomorphism testing algorithms. Given a database $D$, we use a suitable version of the color refinement algorithm to produce a stable coloring of $D$, an assignment from the active domain of $D$ to a set of colors $C_D$. The main ingredient of the color-index is a particular database $D_c$ whose active domain is $C_D$ and whose size is at most $|D|$. Using the color-index, we can evaluate any free-connex ACQ $Q$ over $D$ with preprocessing time $O(|Q| \\cdot |D_c|)$ and constant delay enumeration. Furthermore, we can also count the number of results of $Q$ over $D$ in time $O(|Q| \\cdot |D_c|)$. Given that $|D_c|$ could be much smaller than $|D|$ (even constant-size for some families of databases), the color-index is the first index structure for evaluating free-connex ACQs that allows efficient enumeration and counting with performance that may be strictly smaller than the database size.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2302407026",
                    "name": "Cristian Riveros"
                },
                {
                    "authorId": "2212031884",
                    "name": "Benjamin Scheidt"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "ae0cf2d1672416b0339ec6e88d4b427a21da7c4f",
            "title": "Counting Homomorphisms from Hypergraphs of Bounded Generalised Hypertree Width: A Logical Characterisation",
            "abstract": "We introduce the 2-sorted counting logic $GC^k$ that expresses properties of hypergraphs. This logic has available k variables to address hyperedges, an unbounded number of variables to address vertices, and atomic formulas E(e,v) to express that a vertex v is contained in a hyperedge e. We show that two hypergraphs H, H' satisfy the same sentences of the logic $GC^k$ if, and only if, they are homomorphism indistinguishable over the class of hypergraphs of generalised hypertree width at most k. Here, H, H' are called homomorphism indistinguishable over a class C if for every hypergraph G in C the number of homomorphisms from G to H equals the number of homomorphisms from G to H'. This result can be viewed as a generalisation (from graphs to hypergraphs) of a result by Dvorak (2010) stating that any two (undirected, simple, finite) graphs H, H' are indistinguishable by the (k+1)-variable counting logic $C^{k+1}$ if, and only if, they are homomorphism indistinguishable on the class of graphs of tree width at most k.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2212031884",
                    "name": "Benjamin Scheidt"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "3b7c8b2cbf59e8ee22a38934fad4a13461009f7d",
            "title": "Query Evaluation over SLP-Represented Document Databases with Complex Document Editing",
            "abstract": "It is known that the query result of a regular spanner over a single document D can be enumerated after O(|D|) preprocessing and with constant delay in data complexity (Florenzano et al., ACM TODS 2020, Amarilli et al., ACM TODS 2021). It has been shown (Schmid and Schweikardt, PODS'21) that if the document is represented by a straight-line program (SLP) S, then enumeration is possible with a delay of O(log |D|), but with preprocessing that is linear in |S| (which, in the best case, is logarithmic in |D|). Hence, this compressed setting allows for spanner evaluation in sub-linear time, i.e., with logarithmic upper bounds for preprocessing and delay, if the document is highly-compressible. In this work, we extend these results to the dynamic setting. We consider a document database DDB = D1, D2, ..., Dm that is represented by an SLP SDDB, and that supports regular spanners M1, M2, ..., Mk (meaning that we have data structures at our disposal that allow O(log |Di|)-delay enumeration of the result of spanner Mj on document Di). Then we can perform an update by manipulating the existing documents of DDB by a sequence of text-editing operations commonly found in text-editors (like copy and paste, deleting, or copying factors, concatenating documents etc.), and add the thus constructed document to the database. Such an operation is called complex document editing and is given by an expression \u03c6 in a suitable algebra. Moreover, after this operation, the document database still supports all the regular spanners M1, ..., Mk. The total time required for such an update is O(k |\u03c6| log d), where d is the maximum length of any intermediate document constructed in the complex document editing described by \u03c6. We stress the fact that the size |SDDB| of the SLP (which upper bounds the preprocessing in the static case) is potentially logarithmic in the data, but generally depends on the compressibility of the documents (in the worst case, it is even linear in the data). In contrast to that, we can guarantee that the dependency on the data of our updates is logarithmic regardless of the actual compression achieved by the SLP. In particular, any such update performed by complex document editing adds documents whose length may be exponentially larger than the time needed for performing such an update. Our approach hinges on balancing properties of SLPs, and for our updates it is vital to manipulate the SLP that represents the database in such a way that these balancing properties are maintained.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2408414",
                    "name": "Markus L. Schmid"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "4ce3e861cbf76a6f8f28bd0fbceb31296962c5e0",
            "title": "Answering (Unions of) Conjunctive Queries using Random Access and Random-Order Enumeration",
            "abstract": "As data analytics becomes more crucial to digital systems, so grows the importance of characterizing the database queries that admit a more efficient evaluation. We consider the tractability yardstick of answer enumeration with a polylogarithmic delay after a linear-time preprocessing phase. Such an evaluation is obtained by constructing, in the preprocessing phase, a data structure that supports polylogarithmic-delay enumeration. In this article, we seek a structure that supports the more demanding task of a \u201crandom permutation\u201d: polylogarithmic-delay enumeration in truly random order. Enumeration of this kind is required if downstream applications assume that the intermediate results are representative of the whole result set in a statistically meaningful manner. An even more demanding task is that of \u201crandom access\u201d: polylogarithmic-time retrieval of an answer whose position is given. We establish that the free-connex acyclic CQs are tractable in all three senses: enumeration, random-order enumeration, and random access; and in the absence of self-joins, it follows from past results that every other CQ is intractable by each of the three (under some fine-grained complexity assumptions). However, the three yardsticks are separated in the case of a union of CQs (UCQ): while a union of free-connex acyclic CQs has a tractable enumeration, it may (provably) admit no random access. We identify a fragment of such UCQs where we can guarantee random access with polylogarithmic access time (and linear-time preprocessing) and a more general fragment where we can guarantee tractable random permutation. For general unions of free-connex acyclic CQs, we devise two algorithms with relaxed guarantees: one has logarithmic delay in expectation, and the other provides a permutation that is almost uniformly distributed. Finally, we present an implementation and an empirical study that show a considerable practical superiority of our random-order enumeration approach over state-of-the-art alternatives.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "3393481",
                    "name": "Nofar Carmeli"
                },
                {
                    "authorId": "1471100893",
                    "name": "Shai Zeevi"
                },
                {
                    "authorId": "2321666",
                    "name": "Christoph Berkholz"
                },
                {
                    "authorId": "1856525",
                    "name": "A. Conte"
                },
                {
                    "authorId": "1679226",
                    "name": "B. Kimelfeld"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "5908beeae6e9afc829e5e2dd73b0fb09fee8eaff",
            "title": "Discovering Event Queries from Traces: Laying Foundations for Subsequence-Queries with Wildcards and Gap-Size Constraints",
            "abstract": "We introduce subsequence-queries with wildcards and gap-size constraints (swg-queries, for short) as a tool for querying event traces. An swg-query q is given by a string s over an alphabet of variables and types, a global window size w , and a tuple c = (( c \u2212 1 , c +1 ) , ( c \u2212 2 , c +2 ) , . . . , ( c \u2212| s |\u2212 1 , c + | s |\u2212 1 )) of local gap-size constraints over N \u00d7 ( N \u222a {\u221e} ). The query q matches in a trace t (i. e., a sequence of types) if the variables can uniformly be substituted by types such that the resulting string occurs in t as a subsequence that spans an area of length at most w , and the i th gap of the subsequence (i. e., the distance between the i th and ( i +1) th position of the subsequence) has length at least c \u2212 i and at most c + i . We formalise and investigate the task of discovering an swg-query that describes best the traces from a given sample S of traces, and we present an algorithm solving this task. As a central component, our algorithm repeatedly solves the matching problem (i. e., deciding whether a given query q matches in a given trace t ), which is an NP-complete problem (in combined complexity). Hence, the matching problem is of special interest in the context of query discovery, and we therefore subject it to a detailed (parameterised) complexity analysis to identify tractable subclasses, which lead to tractable subclasses of the discovery problem as well. We complement this by a reduction proving",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2159499070",
                    "name": "Sarah Kleest-Mei\u00dfner"
                },
                {
                    "authorId": "2137380807",
                    "name": "Rebecca Sattler"
                },
                {
                    "authorId": "2408414",
                    "name": "Markus L. Schmid"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2315762",
                    "name": "M. Weidlich"
                }
            ]
        },
        {
            "paperId": "965e8b1a86e7eda86091950844e73514518ed195",
            "title": "Document Spanners - A Brief Overview of Concepts, Results, and Recent Developments",
            "abstract": "The information extraction framework of document spanners was introduced by Fagin, Kimelfeld, Reiss, and Vansummeren (PODS 2013, J. ACM 2015) as a formalisation of the query language AQL, which is used in IBM's information extraction engine SystemT. Since 2013, this framework has been investigated in depth by the principles of database management community and beyond. The present paper gives a brief overview of concepts, results, and recent developments concerning document spanners.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2408414",
                    "name": "Markus L. Schmid"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "3667f558b324d14b8c15854a9b1921ab5edf3537",
            "title": "Locality Properties of Extensions of First-Order Logic and their Use in Algorithms (Abstract of Invited Talk)",
            "abstract": "This talk will give an overview of \ufb01rst-order logic with counting FOC and the weight aggregation logic FOWA. I will provide examples demonstrating the expressiveness of these logics, as well as an overview of locality properties of these logics. The latter allow for e\ufb03cient model checking algorithms and algorithms for learning concepts describable in these logics",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "b186fbc027ab38db80c6dfe1203c09c23697710f",
            "title": "Spanner Evaluation over SLP-Compressed Documents",
            "abstract": "We consider the problem of evaluating regular spanners over compressed documents, i.e., we wish to solve evaluation tasks directly on the compressed data, without decompression. As compressed forms of the documents we use straight-line programs (SLPs) --- a lossless compression scheme for textual data widely used in different areas of theoretical computer science and particularly well-suited for algorithmics on compressed data. In data complexity, our results are as follows. For a regular spanner M and an SLP $\\mathcalS $ of size $\\mathbfs $ that represents a document D, we can solve the tasks of model checking and of checking non-emptiness in time $O(\\mathbfs )$. Computing the set $\u0142lbracket M \\rrbracket(D)$ of all span-tuples extracted from D can be done in time $\u00d8(\\mathbfs |\u0142lbracket M \\rrbracket(D)|)$, and enumeration of $\u0142lbracket M \\rrbracket(D)$ can be done with linear preprocessing $O(\\mathbfs )$ and a delay of $O(depth\\mathcalS )$, where $depth\\mathcalS $ is the depth of $\\mathcalS $'s derivation tree. Note that $\\mathbfs $ can be exponentially smaller than the document's size $|D|$; and, due to known balancing results for SLPs, we can always assume that $depth\\mathcalS = O(log(|D|))$ independent of D's compressibility. Hence, our enumeration algorithm has a delay logarithmic in the size of the non-compressed data and a preprocessing time that is at best (i.e., in the case of highly compressible documents) also logarithmic, but at worst still linear. Therefore, in a big-data perspective, our enumeration algorithm for SLP-compressed documents may nevertheless beat the known linear preprocessing and constant delay algorithms for non-compressed documents.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2408414",
                    "name": "Markus L. Schmid"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "4d706ff44753d0f040d20ed24cfd22b4bbc9cbfb",
            "title": "Constant delay enumeration for conjunctive queries",
            "abstract": "This paper is the tutorial we wish we had had available when starting our own research on constant delay enumeration for conjunctive queries. It provides precise statements and detailed, self-contained proofs of the fundamental results in this area.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2321666",
                    "name": "Christoph Berkholz"
                },
                {
                    "authorId": "2073555110",
                    "name": "Fabian Gerhardt"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "7a846445404402946c82d5e9dda1d7aaf04100ea",
            "title": "Learning Concepts Described by Weight Aggregation Logic",
            "abstract": "We consider weighted structures, which extend ordinary relational structures by assigning weights, i.e. elements from a particular group or ring, to tuples present in the structure. We introduce an extension of first-order logic that allows to aggregate weights of tuples, compare such aggregates, and use them to build more complex formulas. We provide locality properties of fragments of this logic including Feferman-Vaught decompositions and a Gaifman normal form for a fragment called FOW1, as well as a localisation theorem for a larger fragment called FOWA1. This fragment can express concepts from various machine learning scenarios. Using the locality properties, we show that concepts definable in FOWA1 over a weighted background structure of at most polylogarithmic degree are agnostically PAC-learnable in polylogarithmic time after pseudo-linear time preprocessing.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "151472132",
                    "name": "Steffen van Bergerem"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "7c7a1d7ff45ac4104872c6842fa327cc48b2d2f9",
            "title": "Refl-Spanners: A Purely Regular Approach to Non-Regular Core Spanners",
            "abstract": "The regular spanners (characterised by vset-automata) are closed under the algebraic operations of union, join and projection, and have desirable algorithmic properties. The core spanners (introduced by Fagin, Kimelfeld, Reiss, and Vansummeren (PODS 2013, JACM 2015) as a formalisation of the core functionality of the query language AQL used in IBM's SystemT) additionally need string-equality selections and it has been shown by Freydenberger and Holldack (ICDT 2016, Theory of Computing Systems 2018) that this leads to high complexity and even undecidability of the typical problems in static analysis and query evaluation. We propose an alternative approach to core spanners: by incorporating the string-equality selections directly into the regular language that represents the underlying regular spanner (instead of treating it as an algebraic operation on the table extracted by the regular spanner), we obtain a fragment of core spanners that, while having slightly weaker expressive power than the full class of core spanners, arguably still covers the intuitive applications of string-equality selections for information extraction and has much better upper complexity bounds of the typical problems in static analysis and query evaluation.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2408414",
                    "name": "Markus L. Schmid"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "eff753061dc30a936bef0d931003010c8c173f3f",
            "title": "Constant Delay Enumeration with FPT-Preprocessing for Conjunctive Queries of Bounded Submodular Width",
            "abstract": "Marx (STOC~2010, J.~ACM 2013) introduced the notion of submodular width of a conjunctive query (CQ) and showed that for any class $\\Phi$ of Boolean CQs of bounded submodular width, the model-checking problem for $\\Phi$ on the class of all finite structures is fixed-parameter tractable (FPT). Note that for non-Boolean queries, the size of the query result may be far too large to be computed entirely within FPT time. We investigate the free-connex variant of submodular width and generalise Marx's result to non-Boolean queries as follows: For every class $\\Phi$ of CQs of bounded free-connex submodular width, within FPT-preprocessing time we can build a data structure that allows to enumerate, without repetition and with constant delay, all tuples of the query result. Our proof builds upon Marx's splitting routine to decompose the query result into a union of results; but we have to tackle the additional technical difficulty to ensure that these can be enumerated efficiently.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2321666",
                    "name": "Christoph Berkholz"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "c2e5c4a570eaf7ea50ccff1f28bb732b470df797",
            "title": "Local normal forms and their use in algorithmic meta theorems (Invited Talk)",
            "abstract": "This invited talk provides a personal perspective of recent developments concerning local normal forms and their use in algorithmic meta theorems.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "d2a46eff62339ecf8c16f265004074bc88f32fab",
            "title": "Answering (Unions of) Conjunctive Queries using Random Access and Random-Order Enumeration",
            "abstract": "As data analytics becomes more crucial to digital systems, so grows the importance of characterizing the database queries that admit a more efficient evaluation. We consider the tractability yardstick of answer enumeration with a polylogarithmic delay after a linear-time preprocessing phase. Such an evaluation is obtained by constructing, in the preprocessing phase, a data structure that supports polylogarithmic-delay enumeration. In this paper, we seek a structure that supports the more demanding task of a \"random permutation\": polylogarithmic-delay enumeration in truly random order. Enumeration of this kind is required if downstream applications assume that the intermediate results are representative of the whole result set in a statistically valuable manner. An even more demanding task is that of a \"random access\": polylogarithmic-time retrieval of an answer whose position is given. We establish that the free-connex acyclic CQs are tractable in all three senses: enumeration, random-order enumeration, and random access; and in the absence of self-joins, it follows from past results that every other CQ is intractable by each of the three (under some fine-grained complexity assumptions). However, the three yardsticks are separated in the case of a union of CQs (UCQ): while a union of free-connex acyclic CQs has a tractable enumeration, it may (provably) admit no random access. For such UCQs we devise a random-order enumeration whose delay is logarithmic in expectation. We also identify a subclass of UCQs for which we can provide random access with polylogarithmic access time. Finally, we present an implementation and an empirical study that show a considerable practical superiority of our random-order enumeration approach over state-of-the-art alternatives.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "3393481",
                    "name": "Nofar Carmeli"
                },
                {
                    "authorId": "1471100893",
                    "name": "Shai Zeevi"
                },
                {
                    "authorId": "2321666",
                    "name": "Christoph Berkholz"
                },
                {
                    "authorId": "1679226",
                    "name": "B. Kimelfeld"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "0196990a97a37ea161b570ec6db052a2efaba6ec",
            "title": "Gaifman Normal Forms for Counting Extensions of First-Order Logic",
            "abstract": "We consider the extension of first-order logic FO by unary counting quantifiers and generalise the notion of Gaifman normal form from FO to this setting. For formulas that use only ultimately periodic counting quantifiers, we provide an algorithm that computes equivalent formulas in Gaifman normal form. We also show that this is not possible for formulas using at least one quantifier that is not ultimately periodic. Now let d be a degree bound. We show that for any formula phi with arbitrary counting quantifiers, there is a formula gamma in Gaifman normal form that is equivalent to phi on all finite structures of degree <= d. If the quantifiers of phi are decidable (decidable in elementary time, ultimately periodic), gamma can be constructed effectively (in elementary time, in worst-case optimal 3-fold exponential time). For the setting with unrestricted degree we show that by using our Gaifman normal form for formulas with only ultimately periodic counting quantifiers, a known fixed-parameter tractability result for FO on classes of structures of bounded local tree-width can be lifted to the extension of FO with ultimately periodic counting quantifiers (a logic equally expressive as FO+MOD, i.e., first-oder logic with modulo-counting quantifiers).",
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1707683",
                    "name": "D. Kuske"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "4d7392fe67e378236a7bd077ae7fd8c06d1dc70f",
            "title": "Finite-State Map-Reduce Computation and Relational Algebra Queries",
            "abstract": "We introduce three formal models of distributed systems for query evaluation on massive databases: Distributed Streaming with Register Automata (DSAs), Distributed Streaming with Register Transducers (DSTs), and Distributed Streaming with Register Transducers and Joins (DSTJs). These models are based on the map-reduce paradigm where the input is transformed into a dataset of key-value pairs, and on each key a local computation is performed on the values associated with that key resulting in another set of key-value pairs. Computation proceeds in a constant number of rounds, where the result of the last round is the input to the next round, and transformation of key-value pairs is required to be generic. The difference between the three models is in the local computation part. In DSAs it is limited to making one pass over its input using a register automaton, while in DSTs it can make two passes: in the first pass it uses a finite state automaton and in the second it uses a register transducer. The third model DSTJs is an extension of DSTs, where local computations are capable of constructing the Cartesian product of two sets. We obtain the following results: (1) DSAs can evaluate first-order queries over bounded degree databases; (2) DSTs can evaluate semijoin algebra queries over arbitrary databases; (3) DSTJs can evaluate the whole relational algebra over arbitrary databases; (4) DSTJs are strictly stronger than DSTs, which in turn are strictly stronger than DSAs; (5) within DSAs, DSTs, and DSTJs, there is a strict hierarchy w.r.t. the number of rounds.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1786248",
                    "name": "F. Neven"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2058408",
                    "name": "Fr\u00e9d\u00e9ric Servais"
                },
                {
                    "authorId": "143822123",
                    "name": "Tony Tan"
                }
            ]
        },
        {
            "paperId": "53cb50438379c0c4d5229d7e7e1233a6f4768870",
            "title": "2018 ACM PODS Alberto O. Mendelzon Test-of-Time Award",
            "abstract": "In 2007, the PODS Executive Committee established a Test-ofTime Award, named after the late Alberto O. Mendelzon, in recognition of his scientific legacy and his service and dedication to the database community. Mendelzon was an international leader in database theory, whose pioneering and fundamental work has inspired and influenced both database theoreticians and practitioners, and continues to be applied in a variety of advanced settings. He served the database community in many ways: he served as both the Program and the General Chair of the PODS conference, and was instrumental in bringing SIGMOD and PODS together. He was an outstanding educator, who guided the research of numerous doctoral students and postdoctoral fellows. The Award is to be given each year to a paper or a small number of papers published in the PODS proceedings ten years prior, that had the most impact (in terms of research, methodology, or transfer of practice) over the intervening decade. The decision was approved by SIGMOD and ACM. The funds for the Award were contributed by IBM Toronto. The PODS Executive Committee has appointed us to serve as the Award Committee for 2018. After careful consideration and having solicited external nominations and advice, we have selected the following paper as the award winner for 2018: \u201cThe Chase Revisited\" by Alin Deutsch, Alan Nash and Jeff Remmel. Citation. The chase procedure, introduced in the '70s, is a famous technique in the field and has been proved to be important and effective in providing solutions to several problems related to reasoning on data. The paper revisits the standard chase procedure, studying its properties and applicability to classical database problems. Beside settling the open problem of decidability of termination of the standard chase, it investigates the adequacy of the standard chase for a number of data-oriented tasks. The conceptual insight provided by the paper and the technical results presented go much deeper than the modest title of the paper may suggest. They have had a huge impact on the research work carried out in several topics of data management and knowledge bases, including checking query containment under constraints, constraint implication, computing certain answers in data exchange and data integration, query answering in Datalog and its extensions, and ontology-based data access. Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions@acm.org. PODS'18, June 10\u201315, 2018, Houston, TX, USA \u00a9 2018 Copyright is held by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-4706-8/18/06...$15.00 https://doi.org/10.1145/3196959.3196993 Session: Test-of-Time Award and Gems of PODS PODS\u201918, June 10-15, 2018, Houston, TX, USA",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1729232",
                    "name": "M. Lenzerini"
                },
                {
                    "authorId": "144352362",
                    "name": "W. Martens"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "ae68caa2b1c5562e111ea134382dfe56950af4bb",
            "title": "Measuring Congruence on High Dimensional Time Series",
            "abstract": "A time series is a sequence of data items; typical examples are videos, stock ticker data, or streams of temperature measurements. Quite some research has been devoted to comparing and indexing simple time series, i.e., time series where the data items are real numbers or integers. However, for many application scenarios, the data items of a time series are not simple, but high-dimensional data points. Motivated by an application scenario dealing with motion gesture recognition, we develop a distance measure (which we call congruence distance) that serves as a model for the approximate congruency of two multi-dimensional time series. This distance measure generalizes the classical notion of congruence from point sets to multi-dimensional time series. We show that, given two input time series $S$ and $T$, computing the congruence distance of $S$ and $T$ is NP-hard. Afterwards, we present two algorithms that compute an approximation of the congruence distance. We provide theoretical bounds that relate these approximations with the exact congruence distance.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "144662357",
                    "name": "J\u00f6rg P. Bachmann"
                },
                {
                    "authorId": "1751739",
                    "name": "J. Freytag"
                },
                {
                    "authorId": "41018653",
                    "name": "Benjamin Hauskeller"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "caa297bbb7f3d97b47621d1d790695bc8b9364aa",
            "title": "Enumeration for FO Queries over Nowhere Dense Graphs",
            "abstract": "We consider the evaluation of first-order queries over classes of databases that are nowhere dense. The notion of nowhere dense classes was introduced by Nesetril and Ossona de Mendez as a formalization of classes of \"sparse\" graphs and generalizes many well-known classes of graphs, such as classes of bounded degree, bounded tree-width, or bounded expansion. It has recently been shown by Grohe, Kreutzer, and Siebertz that over nowhere dense classes of databases, first-order sentences can be evaluated in pseudo-linear time (pseudo-linear time means that for all \u03b5 there exists an algorithm working in time O(n1+\u03b5), where n is the size of the database). For first-order queries of higher arities, we show that over any nowhere dense class of databases, the set of their solutions can be enumerated with constant delay after a pseudo-linear time preprocessing. In the same context, we also show that after a pseudo-linear time preprocessing we can, on input of a tuple, test in constant time whether it is a solution to the query.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2969169",
                    "name": "L. Segoufin"
                },
                {
                    "authorId": "35032619",
                    "name": "Alexandre Vigny"
                }
            ]
        },
        {
            "paperId": "4fb40376d9a9a4229808a736c432770f7e7dbed6",
            "title": "Answering FO+MOD Queries under Updates on Bounded Degree Databases",
            "abstract": "We investigate the query evaluation problem for fixed queries over fully dynamic databases, where tuples can be inserted or deleted. The task is to design a dynamic algorithm that immediately reports the new result of a fixed query after every database update. We consider queries in first-order logic (FO) and its extension with modulo-counting quantifiers (FO+MOD) and show that they can be efficiently evaluated under updates, provided that the dynamic database does not exceed a certain degree bound. In particular, we construct a data structure that allows us to answer a Boolean FO+MOD query and to compute the size of the result of a non-Boolean query within constant time after every database update. Furthermore, after every database update, we can update the data structure in constant time such that afterwards we are able to test within constant time for a given tuple whether or not it belongs to the query result, to enumerate all tuples in the new query result, and to enumerate the difference between the old and the new query result with constant delay between the output tuples. The preprocessing time needed to build the data structure is linear in the size of the database. Our results extend earlier work on the evaluation of first-order queries on static databases of bounded degree and rely on an effective Hanf normal form for FO+MOD recently obtained by Heimberg, Kuske, and Schweikardt (LICS 2016).",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2321666",
                    "name": "Christoph Berkholz"
                },
                {
                    "authorId": "9560380",
                    "name": "Jens Keppeler"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "beaa394dc58916d6862560188aa35ac268e00029",
            "title": "Answering Conjunctive Queries under Updates",
            "abstract": "We consider the task of enumerating and counting answers to k-ary conjunctive queries against relational databases that may be updated by inserting or deleting tuples. We exhibit a new notion of q-hierarchical conjunctive queries and show that these can be maintained efficiently in the following sense. During a linear time pre-processing phase, we can build a data structure that enables constant delay enumeration of the query results; and when the database is updated, we can update the data structure and restart the enumeration phase within constant time. For the special case of self-join free conjunctive queries we obtain a dichotomy: if a query is not q-hierarchical, then query enumeration with sublinear *) delay and sublinear update time (and arbitrary preprocessing time) is impossible. For answering Boolean conjunctive queries and for the more general problem of counting the number of solutions of k-ary queries we obtain complete dichotomies: if the query's homomorphic core is q-hierarchical, then size of the the query result can be computed in linear time and maintained with constant update time. Otherwise, the size of the query result cannot be maintained with sublinear update time. All our lower bounds rely on the OMv-conjecture, a conjecture on the hardness of online matrix-vector multiplication that has recently emerged in the field of fine-grained complexity to characterise the hardness of dynamic problems. The lower bound for the counting problem additionally relies on the orthogonal vectors conjecture, which in turn is implied by the strong exponential time hypothesis.*) By sublinear we mean O(n(1-\u03b5) for some \u03b5 > 0, where n is the size of the active domain of the current database.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2321666",
                    "name": "Christoph Berkholz"
                },
                {
                    "authorId": "9560380",
                    "name": "Jens Keppeler"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "cbfb49e965e3ef38564625beecc499f0400697c5",
            "title": "Answering UCQs under updates and in the presence of integrity constraints",
            "abstract": "We investigate the query evaluation problem for fixed queries over fully dynamic databases where tuples can be inserted or deleted. The task is to design a dynamic data structure that can immediately report the new result of a fixed query after every database update. We consider unions of conjunctive queries (UCQs) and focus on the query evaluation tasks testing (decide whether an input tuple belongs to the query result), enumeration (enumerate, without repetition, all tuples in the query result), and counting (output the number of tuples in the query result). \nWe identify three increasingly restrictive classes of UCQs which we call t-hierarchical, q-hierarchical, and exhaustively q-hierarchical UCQs. Our main results provide the following dichotomies: If the query's homomorphic core is t-hierarchical (q-hierarchical, exhaustively q-hierarchical), then the testing (enumeration, counting) problem can be solved with constant update time and constant testing time (delay, counting time). Otherwise, it cannot be solved with sublinear update time and sublinear testing time (delay, counting time), unless the OV-conjecture and/or the OMv-conjecture fails. \nWe also study the complexity of query evaluation in the dynamic setting in the presence of integrity constraints, and we obtain according dichotomy results for the special case of small domain constraints (i.e., constraints which state that all values in a particular column of a relation belong to a fixed domain of constant size).",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2321666",
                    "name": "Christoph Berkholz"
                },
                {
                    "authorId": "9560380",
                    "name": "Jens Keppeler"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "e43667d7aaaa69e9f96cf01bebbe826d2ead7af9",
            "title": "First-order logic with counting",
            "abstract": "We introduce the logic FOCN(\u2119) which extends first-order logic by counting and by numerical predicates from a set \u2119, and which can be viewed as a natural generalisation of various counting logics that have been studied in the literature.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1707683",
                    "name": "D. Kuske"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "f3284d3fd6be7eaca3e1627c7b7e1340890dda69",
            "title": "First-Order Query Evaluation with Cardinality Conditions",
            "abstract": "We study an extension of first-order logic FO that allows to express cardinality conditions in a similar way as SQL's COUNT operator. The corresponding logic FOC(P) was introduced by Kuske and Schweikardt, who showed that query evaluation for this logic is fixed-parameter tractable on classes of databases of bounded degree. In this paper, we first show that the fixed-parameter tractability of FOC(P) cannot even be generalised to very simple classes of databases of unbounded degree such as unranked trees or strings with a linear order relation. Then, we identify a fragment FOC1(P) of FOCP which is still extends FO and is sufficiently strong to express standard applications of SQL's COUNT operator. Our main result shows that query evaluation for FOC1(P) is fixed-parameter tractable on nowhere dense classes of databases. This, in particular, implies that the counting problem for first-order queries on nowhere dense classes is fixed-parameter tractable.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "12291f90dfe739bd2bc0d37727a1b14fddc85539",
            "title": "On the locality of arb-invariant first-order formulas with modulo counting quantifiers",
            "abstract": "We study Gaifman locality and Hanf locality of an extension of first-order\nlogic with modulo p counting quantifiers (FO+MOD_p, for short) with arbitrary\nnumerical predicates. We require that the validity of formulas is independent\nof the particular interpretation of the numerical predicates and refer to such\nformulas as arb-invariant formulas. This paper gives a detailed picture of\nlocality and non-locality properties of arb-invariant FO+MOD_p. For example, on\nthe class of all finite structures, for any p >= 2, arb-invariant FO+MOD_p is\nneither Hanf nor Gaifman local with respect to a sublinear locality radius.\nHowever, in case that p is an odd prime power, it is weakly Gaifman local with\na polylogarithmic locality radius. And when restricting attention to the class\nof string structures, for odd prime powers p, arb-invariant FO+MOD_p is both\nHanf and Gaifman local with a polylogarithmic locality radius. Our negative\nresults build on examples of order-invariant FO+MOD_p formulas presented in\nNiemist\\\"o's PhD thesis. Our positive results make use of the close connection\nbetween FO+MOD_p and Boolean circuits built from NOT-gates and AND-, OR-, and\nMOD_p- gates of arbitrary fan-in.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2712100",
                    "name": "Frederik Harwath"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "456463b848f3999f65bea21ad815fc4f3f81c390",
            "title": "Hanf normal form for first-order logic with unary counting quantifiers",
            "abstract": "We study the existence of Hanf normal forms for extensions FO(Q) of first-order logic by sets ${\\mathbf{Q}} \\subseteq \\mathcal{P}(\\mathbb{N})$ of unary counting quantifiers. A formula is in Hanf normal form if it is a Boolean combination of formulas $\\xi (\\bar x)$ describing the isomorphism type of a local neighbourhood around its free variables $\\bar x$ and statements of the form \"the number of witnesses y of \u03c8(y) belongs to (Q+k)\" here Q \u2208 Q, k \u2208 \u2115, and \u03c8 describes the isomorphism type of a local neighbourhood around its unique free variable y.We show that a formula from FO(Q) can be transformed into a formula in Hanf normal form that is equivalent on all structures of degree \u2a7d d if, and only if, all counting quantifiers occurring in the formula are ultimately periodic. This transformation can be carried out in worst-case optimal 3-fold exponential time.In particular, this yields an algorithmic version of Nurmonen\u2019s extension of Hanf\u2019s theorem for first-order logic with modulo-counting quantifiers. As an immediate consequence, we obtain that on finite structures of degree \u2a7d d, model checking of first-order logic with modulo-counting quantifiers is fixed-parameter tractable.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "3425442",
                    "name": "Lucas Heimberg"
                },
                {
                    "authorId": "1707683",
                    "name": "D. Kuske"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "e43e1181443bc527ad3e5f5ac42f4696ac1d2601",
            "title": "Monadic Datalog Containment on Trees Using the Descendant-Axis",
            "abstract": "In their AMW14-paper, Frochaux, Grohe, and Schweikardt showed that the query containment problem for monadic datalog on finite unranked labeled trees is Exptime-complete when (a) considering unordered trees using the child-axis, and when (b) considering ordered trees using the axes firstchild, nextsibling, and child. Furthermore, when allowing to use also the descendant-axis, the query containment problem was shown to be solvable in 2-fold exponential time, but it remained open to determine the problems exact complexity in presence of the descendant-axis. The present paper closes this gap by showing that, in the presence of the descendant-axis, the problem is 2Exptime-hard.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2830763",
                    "name": "Andr\u00e9 Frochaux"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "92cc1cbdd8b02624de89d5ab52f8282c24092afa",
            "title": "Using Locality for Efficient Query Evaluation in Various Computation Models (Invited Talk)",
            "abstract": "In the database theory and logic literature, different notions of locality of queries have been studied, the most prominent being Hanf locality and Gaifman locality. These notions are designed so that, in order to evaluate a local query in a given database, it suffices to look only at small neighbourhoods around tuples of elements that belong to the database. \n \nIn this talk I want to give a survey of how to use locality for efficient query evaluation in various computation models. In particular, we will take a closer look at how to enumerate query results with constant delay, and at how to evaluate queries in a map-reduce like setting [Neven et al., ICDT 2015] or in Pregel [Malewicz et al., SIGMOD 2010]. Also, we will have a closer look at how to transform a given local query into a form suitable for exploiting its locality.",
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "aa8412abd6aacec31547b6b1aa5389a97c8e7291",
            "title": "Distributed Streaming with Finite Memory",
            "abstract": "We introduce three formal models of distributed systems for query evaluation on massive databases: Distributed Streaming with Register Automata (DSAs), Distributed Streaming with Register Transducers (DSTs), and Distributed Streaming with Register Transducers and Joins (DSTJs). These models are based on the key-value paradigm where the input is transformed into a dataset of key-value pairs, and on each key a local computation is performed on the values associated with that key resulting in another set of key-value pairs. Computation proceeds in a constant number of rounds, where the result of the last round is the input to the next round, and transformation to key-value pairs is required to be generic. The dierence between the three models is in the local computation part. In DSAs it is limited to making one pass over its input using a register automaton, while in DSTs it can make two passes: in the first pass it uses a finitestate automaton and in the second it uses a register transducer. The third model DSTJs is an extension of DSTs, where local computations are capable of constructing the Cartesian product of two sets. We obtain the following results: (1) DSAs can evaluate first-order queries over bounded degree databases; (2) DSTs can evaluate semijoin algebra queries over arbitrary databases; (3) DSTJs can evaluate the whole relational algebra over arbitrary databases; (4) DSTJs are strictly stronger than DSTs, which in turn, are strictly stronger than DSAs; (5) within DSAs, DSTs and DSTJs there is a strict hierarchy w.r.t. the number of rounds.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1786248",
                    "name": "F. Neven"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2058408",
                    "name": "Fr\u00e9d\u00e9ric Servais"
                },
                {
                    "authorId": "143822123",
                    "name": "Tony Tan"
                }
            ]
        },
        {
            "paperId": "2f5ed4342aa2d915b32db4c3a77234a56649ddfc",
            "title": "Monadic Datalog Containment on Trees",
            "abstract": "We show that the query containment problem for monadic datalog on finite unranked labeled trees can be solved in 2-fold exponential time when (a) considering unordered trees using the axes child and descendant, and when (b) considering ordered trees using the axes firstchild, nextsibling, child, and descendant. When omitting the descendant-axis, we obtain that in both cases the problem is EXPTIME-complete.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2830763",
                    "name": "Andr\u00e9 Frochaux"
                },
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "7c7b85101f91bff33ec15bdc4fa3dd7e617d7c2d",
            "title": "On Hanf-equivalence and the number of embeddings of small induced subgraphs",
            "abstract": "Two graphs are Hanf-equivalent with respect to radius r if there is a bijection between their vertex sets which preserves the isomorphism types of the vertices' neighbourhoods of radius r. For r = 1 this means that the graphs have the same degree sequence. In this paper we relate Hanf-equivalence to the graph-theoretical concept of subgraph equivalence. To make this concept applicable to graphs that are not necessarily connected, we first generalise the notion of the radius of a connected graph to general graphs in a suitable way, which we call the generalised radius. We say that two graphs G and H are subgraph-equivalent up to generalised radius r if for all graphs S of generalised radius r, the number of induced subgraphs isomorphic to S is the same in G and H. We prove that Hanf-equivalence with respect to radius r is equivalent to subgraph-equivalence up to generalised radius r, thereby relating the purely logical and the graph-theoretical concepts in a very strong way. The notion of subgraph-equivalence up to order s is defined accordingly, where all graphs S of order at most s are taken into account. As a corollary we obtain that Hanf-equivalence with respect to radius r implies subgraph-equivalence up to order s, provided that r \u2265 3s/4. In particular, this implies that two graphs which are Hanf-equivalent with respect to radius 3s/4 satisfy exactly the same unions of conjunctive queries of quantifier rank at most s.",
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1720948",
                    "name": "S. Kreutzer"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "7dd184ac6bcd15b3f6fb2f8005e39a59dd147cd3",
            "title": "Proceedings of the Workshops of the EDBT/ICDT 2014 Joint Conference (EDBT/ICDT 2014), Athens, Greece, March 28, 2014",
            "abstract": "MapReduce framework is established as the standard approach for parallel processing of massive amounts of data. In this work, we extend the model of MapReduce scheduling on unrelated processors (Moseley et al., SPAA 2011) and deal with the practically important case of jobs with any number of Map and Reduce tasks. We present a polynomial-time (32 + )-approximation algorithm for minimizing the total weighted completion time in this setting. To the best of our knowledge, this is the most general setting of MapReduce scheduling for which an approximation guarantee is known. Moreover, this is the first time that a constant approximation ratio is obtained for minimizing the total weighted completion time on unrelated processors under a nontrivial class of precedence constraints.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1720972",
                    "name": "K. Candan"
                },
                {
                    "authorId": "1403657578",
                    "name": "S. Amer-Yahia"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2067225211",
                    "name": "V. Leroy"
                }
            ]
        },
        {
            "paperId": "7fea69056bb7d77452f70ce56e07f49240fd9b11",
            "title": "Enumerating answers to first-order queries over databases of low degree",
            "abstract": "A class of relational databases has low degree if for all \u03b4, all but finitely many databases in the class have degree at most n\u03b4, where n is the size of the database. Typical examples are databases of bounded degree or of degree bounded by log n. It is known that over a class of databases having low degree, first-order boolean queries can be checked in pseudo-linear time, i.e. in time bounded by n1+\u03b5, for all \u03b5. We generalise this result by considering query evaluation. We show that counting the number of answers to a query can be done in pseudo-linear time and that enumerating the answers to a query can be done with constant delay after a pseudo-linear time preprocessing.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "143728959",
                    "name": "Arnaud Durand"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2969169",
                    "name": "L. Segoufin"
                }
            ]
        },
        {
            "paperId": "a28fd24ede1facb6188e8bb6c96c6b2b11d9296d",
            "title": "Preservation and decomposition theorems for bounded degree structures",
            "abstract": "We provide elementary algorithms for two preservation theorems for first-order sentences with modulo m counting quantifiers (FO+MODm) on the class Cd of all finite structures of degree at most d: For each FO+MODm-sentence that is preserved under extensions (homomorphisms) on Cd, a Cd-equivalent existential (existential-positive) FO-sentence can be constructed in 6-fold (4-fold) exponential time. For FO-sentences, the algorithm has 5-fold (4-fold) exponential time complexity. This is complemented by lower bounds showing that for FO-sentences a 3-fold exponential blow-up of the computed existential (existential-positive) sentence is unavoidable. Furthermore, we show that for an input FO-formula, a Cd-equivalent Feferman-Vaught decomposition can be computed in 3-fold exponential time. We also provide a matching lower bound.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2712100",
                    "name": "Frederik Harwath"
                },
                {
                    "authorId": "3425442",
                    "name": "Lucas Heimberg"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "1c742e1fbd1f94be57d5d38d95a10b5a95bb0731",
            "title": "A note on monadic datalog on unranked trees",
            "abstract": "In the article Recursive queries on trees and data trees (ICDT\u201913), Abiteboul et al. asked whether the containment problem for monadic datalog over unordered unranked labeled trees using the child relation and the descendant relation is decidable. This note gives a positive answer to this question, as well as an overview of the relative expressive power of monadic datalog on various representations of unranked trees.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2830763",
                    "name": "Andr\u00e9 Frochaux"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "20ef3f388a93300136df42268d4006b306e6fde1",
            "title": "On the locality of arb-invariant first-order logic with modulo counting quantifiers",
            "abstract": "We study Gaifman and Hanf locality of an extension of first-order logic with modulo p counting quantifiers (FO+MODp, for short) with arbitrary numerical predicates. We require that the validity of formulas is independent of the particular interpretation of the numerical predicates and refer to such formulas as arb-invariant formulas. This paper gives a detailed picture of locality and non-locality properties of arb-invariant FO+MODp. For example, on the class of all finite structures, for any p >= 2, arb-invariant FO+MODp is neither Hanf nor Gaifman local with respect to a sublinear locality radius. However, in case that p is an odd prime power, it is weakly Gaifman local with a polylogarithmic locality radius. And when restricting attention to the class of string structures, for odd prime powers p, arb-invariant FO+MODp is both Hanf and Gaifman local with a polylogarithmic locality radius. Our negative results build on examples of order-invariant FO+MODp formulas presented in Niemisto's PhD thesis. Our positive results make use of the close connection between FO+MODp and Boolean circuits built from NOT-gates and AND-, OR-, and MODp-gates of arbitrary fan-in.",
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "2712100",
                    "name": "Frederik Harwath"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "22d23044ef3119a9c8318b1639bcdc41e80e78a3",
            "title": "Data Exchange, Integration, and Streams",
            "abstract": "The initial and basic role of the chase procedure was to test logical implication between sets of dependencies in order to determine equivalence of database instances known to satisfy a given set of dependencies and to determine query equivalence under database constrains. Recently the chase procedure has experienced a revival due to its application in data exchange. In this chapter we review the chase algorithm and its properties as well as its application in data exchange. 1998 ACM Subject Classification H.2.5 [Heterogeneous Databases]: Data translation",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "103055803",
                    "name": "P. Kolaitis"
                },
                {
                    "authorId": "2258809392",
                    "name": "Maurizio Lenzerini"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "7a97d2150162c5d8a52ca5266563b6c7c6222d0c",
            "title": "An Optimal Gaifman Normal Form Construction for Structures of Bounded Degree",
            "abstract": "This paper's main result presents a 3-fold exponential algorithm that transforms a first-order formula \u03c6 together with a number d into a formula in Gaifman normal form that is equivalent to \u03c6 on the class of structures of degree at most d. For structures of polynomial growth, we even get a 2-fold exponential algorithm. These results are complemented by matching lower bounds: We show that for structures of degree 2, a 2-fold exponential blow-up in the size of formulas cannot be avoided. And for structures of degree 3, a 3-fold exponential blow-up is unavoidable. As a result of independent interest we obtain a 1-fold exponential algorithm which transforms a given first-order sentence \u03c6 of a very restricted shape into a sentence in Gaifman normal form that is equivalent to \u03c6 on all structures.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "3425442",
                    "name": "Lucas Heimberg"
                },
                {
                    "authorId": "1707683",
                    "name": "D. Kuske"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "01b988effcb9d3d5d35372648e97353907d8ad8c",
            "title": "Regular tree languages, cardinality predicates, and addition-invariant FO",
            "abstract": "This paper considers the logic FOcard, i.e., first-order logic with cardinality predicates that can specify the size of a structure modulo some number. We study the expressive power of FOcard on the class of languages of ranked, finite, labelled trees with successor relations. Our first main result characterises the class of FOcard-definable tree languages in terms of algebraic closure properties of the tree languages. As it can be eectively checked whether the language of a given tree automaton satisfies these closure properties, we obtain a decidable characterisation of the class of regular tree languages definable in FOcard. Our second main result considers first-order logic with unary relations, successor relations, and two additional designated symbols < and + that must be interpreted as a linear order and its associated addition. Such a formula is called addition-invariant if, for each fixed interpretation of the unary relations and successor relations, its result is independent of the particular interpretation of < and +. We show that the FOcard-definable tree languages are exactly the regular tree languages definable in addition-invariant first-order logic. Our proof techniques involve tools from algebraic automata theory, reasoning with locality arguments, and the use of logical interpretations. We combine and extend methods developed by Benedikt and Segoufin (ACM ToCL, 2009) and Schweikardt and Segoufin (LICS, 2010).",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2712100",
                    "name": "Frederik Harwath"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "4ac0d2890f4777214856be712fd00b2c79380f77",
            "title": "Locality from Circuit Lower Bounds",
            "abstract": "We study the locality of an extension of first-order logic that captures graph queries computable in ${AC}^0}$, i.e., by families of polynomial-size constant-depth circuits. The extension considers first-order formulas over relational structures which may use arbitrary numerical predicates in such a way that their truth value is independent of the particular interpretation of the numerical predicates. We refer to such formulas as Arb-invariant first-order. We consider the two standard notions of locality, Gaifman and Hanf locality. Our main result gives a Gaifman locality theorem: An Arb-invariant first-order formula cannot distinguish between two tuples that have the same neighborhood up to distance $(\\log n)^c$, where $n$ represents the number of elements in the structure and $c$ is a constant depending on the formula. When restricting attention to string structures, we achieve the same quantitative strength for Hanf locality. In both cases we show that our bounds are tight. We also present an applicati...",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "2109787028",
                    "name": "Matthew W. Anderson"
                },
                {
                    "authorId": "1717488",
                    "name": "D. Melkebeek"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2969169",
                    "name": "L. Segoufin"
                }
            ]
        },
        {
            "paperId": "833ce4884a176d6ff55725891a082f9976a8ffec",
            "title": "Advances and applications of automata on words and trees : abstracts collection",
            "abstract": "From 12.12.2010 to 17.12.2010, the Dagstuhl Seminar 10501 \"Advances and Applications of Automata on Words and Trees\" was held in Schloss Dagstuhl - Leibniz Center for Informatics. During the seminar, several participants presented their current research, and ongoing work and open problems were discussed. Abstracts of the presentations given during the seminar as well as abstracts of seminar results and ideas are put together in this paper. The first section describes the seminar topics and goals in general. Links to extended abstracts or full papers are provided, if available.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1771969",
                    "name": "Christian Gla\u00dfer"
                },
                {
                    "authorId": "145289652",
                    "name": "J. Pin"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "1759890",
                    "name": "V. Selivanov"
                },
                {
                    "authorId": "144944321",
                    "name": "W. Thomas"
                }
            ]
        },
        {
            "paperId": "8871ef734814c231cd2c21bb11abe7bc86b650cc",
            "title": "A note on the expressive power of linear orders",
            "abstract": "This article shows that there exist two particular linear orders such that first- order logic with these two linear orders has the same expressive power as first-order logic with the Bit-predicate FO(Bit). As a corollary we obtain that there also exists a built- in permutation such that first-order logic with a linear order and this permutation is as expressive as FO(Bit).",
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "1736032",
                    "name": "T. Schwentick"
                }
            ]
        },
        {
            "paperId": "8af2977c741c7f9f7b51301d84cbebdb002261cc",
            "title": "Advances and applications of automata on words and trees : executive summary",
            "abstract": "Seminar: 10501 - Advances and Applications of Automata on Words and Trees. The aim of the seminar was to discuss and systematize the recent fast progress in automata theory and to identify important directions for future research. For this, the seminar brought together more than 40 researchers from automata theory and related fields of applications. We had 19 talks of 30 minutes and 5 one-hour lectures leaving ample room for discussions. In the following we describe the topics in more detail.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1771969",
                    "name": "Christian Gla\u00dfer"
                },
                {
                    "authorId": "145289652",
                    "name": "J. Pin"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "1759890",
                    "name": "V. Selivanov"
                },
                {
                    "authorId": "144944321",
                    "name": "W. Thomas"
                }
            ]
        },
        {
            "paperId": "cb63df0ee54b7c56cd229736b0cde1e3d8a3382e",
            "title": "Report on DEIS'10: advanced school on data exchange, information, and streams (A GI-Dagstuhl Seminar)",
            "abstract": "Most computer scientists are familiar with the Schloss Dagstuhl Leibniz Center for Informatics or, simply, Dagstuhl as the place \u201cwhere computer scientists meet\u201d. Over the years, literally thousands of computer scientists have attended one or more Dagstuhl seminars in which participants spend a week interacting with colleagues in an informal setting by sharing new results and work in progress, exchanging ideas, or embarking on new collaborations. Alongside these year-round seminars, however, Dagstuhl also hosts a different kind of event that is expressly geared towards students and postdoctoral scholars. Specifically, Dagstuhl is also the home of the GI-Dagstuhl Seminars, which are sponsored jointly by the German Society for Informatics (GI) and the Schloss Dagstuhl Leibniz Center for Informatics. The designated purpose of GIDagstuhl Seminars is to enable young researchers to learn about new developments in a particular area of research through active engagement in the seminar, which is typically organized by an international team of senior researchers. GI-Dagstuhl Seminars take place by far less frequently than regular Dagstuhl-Seminars; actually, only one or two such seminars has taken place each year during the past six years. Furthermore, GI-Dagstuhl Seminars are limited to at most 20-25 participants, including the organizers. This paper reports on GI-Dagstuhl Seminar 10452, an Advanced School on Data Exchange, Integration, and Streams (DEIS\u201910), which took place from November 7 to November 12, 2010 and was organized by the three authors.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1795872",
                    "name": "Phokion G. Kolaitis"
                },
                {
                    "authorId": "1729232",
                    "name": "M. Lenzerini"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "e68631c1b07bf7319dee22831010dd17d64061b4",
            "title": "Closed world data exchange",
            "abstract": "Data exchange deals with translating data structured in some source format into data structured in some target format, given a specification of the relationship between the source and the target and possibly constraints on the target; and answering queries over the target in a way that is semantically consistent with the information in the source. Theoretical foundations of data exchange have been actively explored recently. It was also noticed that the standard semantics for query answering in data exchange may lead to counterintuitive or anomalous answers.\n In the present article, we explain that this behavior is due to the fact that solutions can contain invented information (information that is not related to the source instance), and that the presence of incomplete information in target instances has been ignored. In particular, proper query evaluation techniques for databases with nulls have not been used, and the distinction between closed and open world semantics has not been made.\n We present a concept of solutions, called CWA-solutions, that is based on the closed world assumption. For data exchange settings without constraints on the target, the space of CWA-solutions has two extreme points: the canonical universal solution (the maximal CWA-solution) and the core of the universal solutions (the minimal CWA-solution), both of them well studied in data exchange. In the presence of constraints on the target, the core of the universal solutions is still the minimal CWA-solution, but there may be no unique maximal CWA-solution. We show how to define the semantics of query-answering taking into account incomplete information, and show that some of the well-known anomalies go away with the new semantics. The article also contains results on the complexity of query-answering, upper approximations to queries (maybe-answers), and various extensions.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1758590",
                    "name": "Andr\u00e9 Hernich"
                },
                {
                    "authorId": "1681226",
                    "name": "L. Libkin"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "1857d7f4e97eaf0b280cd468f095c462620c2820",
            "title": "Addition-Invariant FO and Regularity",
            "abstract": "We consider formulas which, in addition to the symbols in the vocabulary, may use two designated symbols \\prec and + that must be interpreted as a linear order and its associated addition. Such a formula is called addition-invariant if, for each fixed interpretation of the initial vocabulary, its result is independent of the particular interpretation of \\prec and +. This paper studies the expressive power of addition invariant first-order logic, +-inv-FO, on the class of finite strings. Our first main result gives a characterization of the regular languages definable in +-inv-FO: we show that these are exactly the languages definable in FO with extra predicates, denoted by \u201clm\u201d for short, for testing the length of the string modulo some fixed number. Our second main result shows that every language definable in +-inv-FO, that is bounded or commutative or deterministic context-free, is regular. As an immediate consequence of these two main results, we obtain that +-inv-FO is equivalent to FO(lm) on the class of finite colored sets. Our proof methods involve Ehrenfeucht-Fra\u00efss\u00e9 games, tools from algebraic automata theory, and reasoning about semi-linear sets.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "2969169",
                    "name": "L. Segoufin"
                }
            ]
        },
        {
            "paperId": "3bf5a986a067e62d155037a4fa366f50401a1f7b",
            "title": "10501 Executive Summary - Advances and Applications of Automata on Words and Trees",
            "abstract": "The aim of the seminar was to discuss and systematize \nthe recent fast progress in automata theory and to identify \nimportant directions for future research. \nFor this, the seminar brought together more than 40 researchers \nfrom automata theory and related fields of applications. \nWe had 19 talks of 30 minutes and 5 one-hour lectures \nleaving ample room for discussions. \nIn the following we describe the topics in more detail.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1771969",
                    "name": "Christian Gla\u00dfer"
                },
                {
                    "authorId": "145289652",
                    "name": "J. Pin"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "1759890",
                    "name": "V. Selivanov"
                },
                {
                    "authorId": "144944321",
                    "name": "W. Thomas"
                }
            ]
        },
        {
            "paperId": "88bb5df737a21c214022e2cb42af99ec1dbdf1a5",
            "title": "10501 Abstracts Collection - Advances and Applications of Automata on Words and Trees",
            "abstract": "From 12.12.2010 to 17.12.2010, the Dagstuhl Seminar 10501 \n``Advances and Applications of Automata on Words and Trees'' was held \nin Schloss Dagstuhl~--~Leibniz Center for Informatics. \nDuring the seminar, several participants presented their current \nresearch, and ongoing work and open problems were discussed. Abstracts of \nthe presentations given during the seminar as well as abstracts of \nseminar results and ideas are put together in this paper. The first section \ndescribes the seminar topics and goals in general. \nLinks to extended abstracts or full papers are provided, if available.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1771969",
                    "name": "Christian Gla\u00dfer"
                },
                {
                    "authorId": "145289652",
                    "name": "J. Pin"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "1759890",
                    "name": "V. Selivanov"
                },
                {
                    "authorId": "144944321",
                    "name": "W. Thomas"
                }
            ]
        },
        {
            "paperId": "a3dfa17bc105994968e08b50603ddc29b197d3ea",
            "title": "Database theory: query languages",
            "abstract": "This chapter gives an introduction to the theoretical foundations of query languages for relational databases. It thus addresses a significant part of database theory. Special emphasis is put on the expressive power of query languages and the computational complexity of their associated evaluation and static analysis problems.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "1736032",
                    "name": "T. Schwentick"
                },
                {
                    "authorId": "2969169",
                    "name": "L. Segoufin"
                }
            ]
        },
        {
            "paperId": "28b781c2694d0d7848fa3a36b5d8044b1bc54cb8",
            "title": "Lower Bounds for Multi-Pass Processing of Multiple Data Streams",
            "abstract": "T his paper gives a brief overview of computation models for data stream process- ing, and it introduces a new model for multi-pass processing of multiple streams, the so-called mp2s-automata. Two algorithms for solving the set disjointness problem with these automata are presented. The main technical contribution of this paper is the proof of a lower bound on the size of memory and the number of heads that are required for solving the set disjointness problem with mp2s-automata.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "2c65eaf0ad5aa882690b1370978094d9ec958287",
            "title": "Machine models for query processing",
            "abstract": "The massive data sets that have to be processed in many application areas are often far too large to fit completely into a computer\u2019s internal memory. When evaluating queries on such large data sets, the resulting communication between fast internal memory and slower external memory turns out to be a major performance bottleneck. Modern software and database technologies use clever heuristics to minimize the costs produced by external memory accesses. There has been a wealth of research on query processing and optimization along these lines (cf. e.g. [31, 16, 40, 27]), and it seems that the current technologies scale up to current user expectations. Our theoretical understanding of the problems involved, however, is not quite as developed. Most results concerning the computational complexity of query languages are formulated in terms of classical complexity classes such as PTIME or PSPACE. Two examples of such results are that the combined complexity of evaluating relational algebra queries is PSPACE-complete [38, 37] and that the combined complexity of evaluating acyclic conjunctive queries belongs to PTIME [42] and is in fact LogCFL-complete [15]. The classes considered in computational complexity theory are usually based on Turing machines or random access machines, i.e., on machine models that do not take into account the existence of multiple storage media of varying sizes and access characteristics. Since the performance bottleneck for communicating between such storage media is completely ignored in classical complexity classes, \u201cclassical\u201d results on the complexity of query evaluation only give a very rough measure of the complexity of query evaluation on a real computer. In recent years, a number of machine models have been developed that take into account the existence of multiple storage media of varying sizes and access characteristics. These models are particularly useful for studying the complexity of query evaluation on massive data sets. The present paper gives an overview of such machine models. The two \u201cextreme\u201d models are the (very powerful) external memory model, presented in Section 2,",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "a5ebfa9bbdb6082fcf11b089fcf116a09c6e0c19",
            "title": "Lower bounds for processing data with few random accesses to external memory",
            "abstract": "We consider a scenario where we want to query a large dataset that is stored in external memory and does not fit into main memory. The most constrained resources in such a situation are the size of the main memory and the number of random accesses to external memory. We note that sequentially streaming data from external memory through main memory is much less prohibitive.\n We propose an abstract model of this scenario in which we restrict the size of the main memory and the number of random accesses to external memory, but admit arbitrary sequential access. A distinguishing feature of our model is that it allows the usage of unlimited external memory for storing intermediate results, such as several hard disks that can be accessed in parallel.\n In this model, we prove lower bounds for the problem of sorting a sequence of strings (or numbers), the problem of deciding whether two given sets of strings are equal, and two closely related decision problems. Intuitively, our results say that there is no algorithm for the problems that uses internal memory space bounded by N1\u2212\u03f5 and at most o(log N) random accesses to external memory, but unlimited \u201cstreaming access\u201d, both for writing to and reading from external memory. (Here, N denotes the size of the input and \u03f5 is an arbitrary constant greater than 0.) We even permit randomized algorithms with one-sided bounded error. We also consider the problem of evaluating database queries and prove similar lower bounds for evaluating relational algebra queries against relational databases and XQuery and XPath queries against XML-databases.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1758590",
                    "name": "Andr\u00e9 Hernich"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "6cf70d06bdb3b30f94dab61cf8da456ec2f5e98e",
            "title": "Expressive power of monadic logics on words, trees, pictures, and graphs",
            "abstract": "We give a survey of the expressive power of various monadic logics on specific classes of finite labeled graphs, including words, trees, and pictures. Among the logics we consider, there are monadic secondorder logic and its existential fragment, the modal mu-calculus, and monadic least fixed-point logic. We focus on nesting-depth and quantifier alternation as a complexity measure of these logics.",
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "3304527",
                    "name": "O. Matz"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "5aaa9c20499da37b3ed24766030d3c6e986c61a4",
            "title": "CWA-solutions for data exchange settings with target dependencies",
            "abstract": "Data exchange deals with the following problem: given an instance over a source schema, a specification of the relationship between the source and the target,and dependencies on the target, construct an instance over a target schema that satisfies the given relationships and dependencies. Recently - for data exchange settings without target dependencies - Libkin (PODS'06) introduced a new concept of solutions based on the closed world assumption (so calledCWA-solutions), and showed that, in some respects, this new notion behaves better than the standard notion of solutions considered in previous papers on data exchange. The present paper extends Libkin's notion of CWA-solutions to data exchange settings with target dependencies. We show that, when restricting attention to data exchange settings with weakly acyclic target dependencies, this new notion behaves similarly as before: the core is the unique \"minimal\" CWA-solution, and computing CWA-solutions as well as certain answers to positive queries is possible in polynomial time and can be PTIME-hard. However, there may be more than one \"maximal\" CWA-solution. And going beyond the class of positive queries, we obtain that there are conjunctive queries with (just) one inequality, for which evaluating the certain answers is coNP-hard. Finally, we consider the EXISTENCE-OF-CWA-SOLUTIONS problem: while the problem is tractable for data exchange settings with weakly acyclic target dependencies, it turns out to be undecidable for general data exchange settings. As a consequence, we obtain that also the EXISTENCE-OF-UNIVERSAL-SOLUTIONS problem is undecidable in genera.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1758590",
                    "name": "Andr\u00e9 Hernich"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "aaf22d174a86a3649e3498f9ec2c7fef4f45d205",
            "title": "Machine models and lower bounds for query processing",
            "abstract": "This paper gives an overview of recent work on machine models for processing massive amounts of data. The main focus is on generalizations of the classical data stream model where, apart from an \"internal memory\" of limited size, also a number of (potentially huge) streams may be used as \"external memory devices\".",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "4d78711e6ee93a7f77002c6720678bb37019a439",
            "title": "Randomized computations on large data sets: tight lower bounds",
            "abstract": "We study the randomized version of a computation model (introduced in [9, 10]) that restricts random access to external memory and internal memory space. Essentially, this model can be viewed as a powerful version of a data stream model that puts no cost on sequential scans of external memory (as other models for data streams) and, in addition, (like other external memory models, but unlike streaming models), admits several large external memory devices that can be read and written to in parallel.We obtain tight lower bounds for the decision problems set equality, multiset equality, and checksort. More precisely, we show that any randomized one-sided-error bounded Monte Carlo algorithm for these problems must perform \u03a9(logN) random accesses to external memory devices, provided that the internal memory size is at most O(4\u221aN/logN), where N denotes the size of the input data.From the lower bound on the set equality problem we can infer lower bounds on the worst case data complexity of query evaluation for the languages XQuery, XPath, and relational algebra on streaming data. More precisely, we show that there exist queries in XQuery, XPath, and relational algebra, such that any (randomized) Las Vegas algorithm that evaluates these queries must perform \u03a9(logN) random accesses to external memory devices, provided that the internal memory size is at most O(4\u221aN/logN).",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1758590",
                    "name": "Andr\u00e9 Hernich"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "74646b47dd47081846e9f6d950c841aec634ae9d",
            "title": "Approximation Schemes for First-Order Definable Optimisation Problems",
            "abstract": "Let phi(X) be a first-order formula in the language of graphs that has a free set variable X, and assume that X only occurs positively in phi(X). Then a natural minimisation problem associated with phi(X) is to find, in a given graph G, a vertex set S of minimum size such that G satisfies phi(S). Similarly, if X only occurs negatively in phi(X), then phi(X) defines a maximisation problem. Many well-known optimisation problems are first-order definable in this sense, for example, minimum dominating set or maximum independent set. We prove that for each class Gscr of graphs with excluded minors, in particular for each class of planar graphs, the restriction of a first-order definable optimisation problem to the class Gscr has a polynomial time approximation scheme. A crucial building block of the proof of this approximability result is a version of Gaifman's locality theorem for formulas positive in a set variable. This result may be of independent interest",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "8645695",
                    "name": "A. Dawar"
                },
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1720948",
                    "name": "S. Kreutzer"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "6cfe064ec1222ee3bb59b47c88dbb352afc89871",
            "title": "Lower bounds for sorting with few random accesses to external memory",
            "abstract": "We consider a scenario where we want to query a large dataset that is stored in external memory and does not fit into main memory. The most constrained resources in such a situation are the size of the main memory and the number of random accesses to external memory. We note that sequentially streaming data from external memory through main memory is much less prohibitive.We propose an abstract model of this scenario in which we restrict the size of the main memory and the number of random accesses to external memory, but do not restrict sequential reads. A distinguishing feature of our model is that it admits the usage of unlimited external memory for storing intermediate results, such as several hard disks that can be accessed in parallel. In practice, such auxiliary external memory can be crucial. For example, in a first sequential pass the data can be annotated, and in a second pass this annotation can be used to answer the query. Koch's [9] ARB system for answering XPath queries is based on such a strategy.In this model, we prove lower bounds for sorting the input data. As opposed to related results for models without auxiliary external memory for intermediate results, we cannot rely on communication complexity to establish these lower bounds. Instead, we simulate. our model by a non-uniform computation model for which we can establish the lower bounds by combinatorial means.",
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "75d20b0ec98701a605ffbe5488e59a214f2e4992",
            "title": "The succinctness of first-order logic on linear orders",
            "abstract": "Succinctness is a natural measure for comparing the strength of different logics. Intuitively, a logic L/sub 1/ is more succinct than another logic L/sub 2/ if oil properties that can be expressed in L/sub 2/ can be expressed in L/sub 1/ by formulas of (approximately) the same size, but some properties can be expressed in L/sub 1/ by (significantly) smaller formulas. We study the succinctness of logics on linear orders that have the same expressive power as first-order logic. Our first theorem is concerned with the finite variable fragments of first-order logic. We prove that:(i) Up to a polynomial factor, the 2- and the 3-variable fragments of first-order logic on linear orders have the same succinctness.(ii) The 4-variable fragment is exponentially more succinct than the 3-variable fragment. Our second main result compares the succinctness of first-order logic on linear orders with that of monadic second-order logic. We prove that the fragment of monadic second-order logic that has the same expressiveness as first-order logic on linear orders is non-elementarily more succinct than first-order logic.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "db6f7afba0e54b2762a739e0b0842743889173cc",
            "title": "Comparing the succinctness of monadic query languages over finite trees",
            "abstract": "We study the succinctness of monadic second-order logic and a variety of monadic fixed point logics on trees. All these languages are known to have the same expressive power on trees, but some can express the same queries much more succinctly than others. For example, we show that, under some complexity theoretic assumption, monadic second-order logic is non-elementarily more succinct than monadic least fixed point logic, which in turn is non-elementarily more succinct than monadic datalog.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1744396",
                    "name": "Martin Grohe"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "ec3abffba634e3e817330374f9b5e9cf1e3e5a4e",
            "title": "Arithmetic, first-order logic, and counting quantifiers",
            "abstract": "This article gives a thorough overview of what is known about first-order logic with counting quantifiers and with arithmetic predicates. As a main theorem we show that Presburger arithmetic is closed under unary counting quantifiers. Precisely, this means that for every first-order formula \u03d5(y,z) over the signature {<,+} there is a first-order formula \u03c8(x,z) which expresses over the structure \u27e8&U2115;,<,+\u27e9 (respectively, over initial segments of this structure) that the variable x is interpreted exactly by the number of possible interpretations of the variable y for which the formula \u03d5(y,z) is satisfied. Applying this theorem, we obtain an easy proof of Ruhl's result that reachability (and similarly, connectivity) in finite graphs is not expressible in first-order logic with unary counting quantifiers and addition. Furthermore, the above result on Presburger arithmetic helps to show the failure of a particular version of the Crane Beach conjecture.",
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "authors": [
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                }
            ]
        },
        {
            "paperId": "f283078df3653e1e5d487234bcd127226f54c0e1",
            "title": "The Monadic Quantifier Alternation Hierarchy over Grids and Graphs",
            "abstract": "The monadic second-order quantifier alternation hierarchy over the class of finite graphs is shown to be strict. The proof is based on automata theoretic ideas and starts from a restricted class of graph-like structures, namely finite two-dimensional grids. Considering grids where the width is a function of the height, we prove that the difference between the levels k + 1 and k of the monadic hierarchy is witnessed by a set of grids where this function is (k + 1)-fold exponential. We then transfer the hierarchy result to the class of directed (or undirected) graphs, using an encoding technique called strong reduction. It is notable that one can obtain sets of graphs which occur arbitrarily high in the monadic hierarchy but are already definable in the first-order closure of existential monadic second-order logic. We also verify that these graph properties even belong to the complexity class NLOG. which indicates a profound difference between the monadic hierarchy and the polynomial hierarchy.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "3304527",
                    "name": "O. Matz"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "144944321",
                    "name": "W. Thomas"
                }
            ]
        },
        {
            "paperId": "20089398b35dd0ac21ca46b14abe9bf7f9a15e5d",
            "title": "The Crane Beach Conjecture",
            "abstract": "A language L over an alphabet A is said to have a neutral letter if there is a letter e/spl isin/A such that inserting or deleting e's from any word in A* does not change its membership (or non-membership) in L. The presence of a neutral letter affects the definability of a language in first-order logic. It was conjectured that it renders all numerical predicates apart from the order predicate useless, i.e., that if a language L with a neutral letter is not definable in first-order logic with linear order then it is not definable in first-order. Logic with any set /spl Nscr/ of numerical predicates. We investigate this conjecture in detail, showing that it fails already for /spl Nscr/={+, *}, or possibly stronger for any set /spl Nscr/ that allows counting up to the m times iterated logarithm, 1g/sup (m)/, for any constant m. On the positive side, we prove the conjecture for the case of all monadic numerical predicates, for /spl Nscr/={+}, for the fragment BC(/spl Sigma/) of first-order logic, and for binary alphabets.",
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "authors": [
                {
                    "authorId": "1832411",
                    "name": "D. M. Barrington"
                },
                {
                    "authorId": "1808597",
                    "name": "N. Immerman"
                },
                {
                    "authorId": "1767683",
                    "name": "C. Lautemann"
                },
                {
                    "authorId": "1691736",
                    "name": "Nicole Schweikardt"
                },
                {
                    "authorId": "1754510",
                    "name": "D. Th\u00e9rien"
                }
            ]
        }
    ]
}